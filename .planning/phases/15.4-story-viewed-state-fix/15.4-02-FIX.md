---
phase: 15.4-story-viewed-state-fix
plan: 02-FIX
type: fix
---

<objective>
Fix 3 remaining UAT issues from Phase 15.4 verification.

Source: .planning/ISSUES.md (ISS-006, ISS-007, ISS-008)
Priority: 2 high, 1 medium
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**

- ISS-006: Own story ring indicator doesn't update after viewing
- ISS-007: Own story doesn't resume at correct position
- ISS-008: Reactions not sorting by count (highest left)

**Key files:**
@src/screens/FeedScreen.js
@src/hooks/useViewedStories.js
@src/hooks/usePhotoDetailModal.js

**Root cause analysis:**

**ISS-006 & ISS-007 (Own story issues):**

The `viewedPhotoCount` dependency added in 15.4-01-FIX triggers re-renders when photos are marked as viewed. However, there are two potential issues:

1. **Async timing issue:** `markPhotosAsViewed` updates `viewedPhotosRef` immediately (sync) and `viewedPhotos` state (async). The `viewedPhotoCount` derives from state, not ref. If the render happens before state update completes, the check uses stale data.

2. **Photo ID mismatch:** The `myStories.topPhotos` array is fetched once on mount. If photo IDs in Firestore don't match what's being marked as viewed (e.g., different document reference), `hasViewedAllPhotos` will never return true.

**Debug approach:** Add logging to trace:

- Photo IDs in `myStories.topPhotos`
- Photo IDs being marked as viewed
- `viewedPhotosRef.current` contents after marking
- `hasViewedAllPhotos` return value for those IDs

**ISS-008 (Reaction sorting):**

Looking at `usePhotoDetailModal.js`, the `orderedEmojis` memo correctly sorts by `totalCount` (line 194-196). The sorting code is correct:

```javascript
.sort((a, b) => b.totalCount - a.totalCount)
```

However, the issue may be:

1. **Frozen order persisting:** After tapping an emoji, `frozenOrder` freezes the display order for 1.5 seconds. If user closes/reopens stories during this freeze, the frozen (unsorted) order might persist incorrectly.
2. **State not resetting:** When photo changes or modal reopens, `frozenOrder` might not be cleared.
3. **Component not re-rendering:** The memo dependencies might be missing something.

**Debug approach:** Add logging to trace:

- `frozenOrder` state on render
- `orderedEmojis` result vs `groupedReactions` counts
- When `frozenOrder` is set/cleared
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Debug and fix own story viewed state (ISS-006, ISS-007)</name>
  <files>src/screens/FeedScreen.js, src/hooks/useViewedStories.js</files>
  <action>
Add debug logging to understand the data flow, then fix the root cause.

**Step 1: Add debug logging in FeedScreen.js**

In `handleOpenMyStories`:

```javascript
const handleOpenMyStories = () => {
  if (!myStories?.hasPhotos) {
    logger.debug('FeedScreen: No own photos to show');
    return;
  }

  // DEBUG: Log photo IDs
  const photoIds = (myStories.topPhotos || []).map(p => p.id);
  logger.debug('FeedScreen: Opening own stories - photo IDs', { photoIds });

  const startIndex = getFirstUnviewedIndex(myStories.topPhotos || []);
  // ... rest of function
};
```

In `handleCloseMyStories`:

```javascript
const handleCloseMyStories = () => {
  logger.debug('FeedScreen: Closing own stories viewer');
  if (myStories) {
    const allPhotos = myStories.topPhotos || [];
    const photoIds = allPhotos.map(p => p.id);

    // DEBUG: Log what we're marking
    logger.debug('FeedScreen: Own story close - marking photos', {
      photoIds,
      currentIndex: storiesCurrentIndexRef.current,
      isAtEnd: storiesCurrentIndexRef.current >= allPhotos.length - 1,
    });

    // ... rest of marking logic
  }
};
```

**Step 2: Add debug logging in useViewedStories.js**

In `markPhotosAsViewed`:

```javascript
// After updating ref and state
logger.debug('useViewedStories: markPhotosAsViewed - state updated', {
  photoIds,
  newSetSize: newSet.size,
  setContents: Array.from(newSet).slice(0, 10), // First 10 for debugging
});
```

In `hasViewedAllPhotos`:

```javascript
const hasViewedAllPhotos = useCallback(
  photos => {
    if (!photos || photos.length === 0) return false;
    const viewed = viewedPhotosRef.current;
    const photoIds = photos.map(p => p.id);
    const allViewed = photos.every(photo => viewed.has(photo.id));

    // DEBUG: Log check
    logger.debug('useViewedStories: hasViewedAllPhotos check', {
      photoIds,
      viewedSetSize: viewed.size,
      allViewed,
      // Show which ones aren't viewed
      notViewed: photoIds.filter(id => !viewed.has(id)),
    });

    return allViewed;
  },
  [viewedPhotos]
);
```

**Step 3: Run app and check logs**

Open own story, view photos, close, check logs for:

- Photo IDs being marked
- Photo IDs being checked in hasViewedAllPhotos
- Whether IDs match

**Step 4: Apply fix based on findings**

Most likely fix: The issue is that `hasViewedAllPhotos` is called during render BEFORE the state update from `markPhotosAsViewed` propagates. The `viewedPhotoCount` dependency should trigger a re-render, but React batches updates.

**Likely solution:** Force a state update in FeedScreen after marking photos as viewed:

```javascript
const handleCloseMyStories = () => {
  logger.debug('FeedScreen: Closing own stories viewer');
  if (myStories) {
    const allPhotos = myStories.topPhotos || [];
    const isAtEnd = storiesCurrentIndexRef.current >= allPhotos.length - 1;

    if (isAtEnd) {
      markAsViewed(myStories.userId);
      const photoIds = allPhotos.map(p => p.id);
      if (photoIds.length > 0) {
        markPhotosAsViewed(photoIds);
      }
    } else {
      const viewedPhotoIds = allPhotos.slice(0, storiesCurrentIndexRef.current + 1).map(p => p.id);
      if (viewedPhotoIds.length > 0) {
        markPhotosAsViewed(viewedPhotoIds);
      }
    }

    // Force myStories state update to trigger re-render with fresh hasViewedAllPhotos check
    // This ensures the ring indicator updates immediately
    setMyStories(prev => (prev ? { ...prev } : prev));
  }
};
```

Wait - that won't help because myStories hasn't changed, we just need the component to re-render with updated viewedPhotosRef.

**Alternative fix:** The issue is likely that `viewedPhotoCount` updates but React doesn't re-render the specific part showing MeStoryCard. Let's ensure the dependency chain is correct.

Actually, let me check if `handleCloseMyStories` is even being called. The mode flags are cleared in the onClose callback wrapper, and `handleCloseMyStories` should be called before that.

Looking at the code more carefully:

```javascript
onClose: () => {
  if (isInStoriesModeRef.current) {
    if (isOwnStoriesRef.current) {
      handleCloseMyStories();  // This is called
    } else {
      handleCloseStories();
    }
  } else {
    currentFeedPhotoRef.current = null;
  }
  isInStoriesModeRef.current = false;
  isOwnStoriesRef.current = false;
},
```

This looks correct. The issue must be in the re-render not happening.

**Final fix approach:**
The `viewedPhotoCount` is a primitive (number), so changing it should trigger re-render. But the issue might be that `markPhotosAsViewed` is async (Firestore persist) and state update batches with navigation.

Add a small delay or use flushSync:

```javascript
// In handleCloseMyStories, after marking photos:
// Schedule a forced re-render check after state settles
setTimeout(() => {
  // Touch a state to force re-render
  setMyStoriesLoading(prev => prev);
}, 50);
```

No, that's hacky. Let me look at this differently.

The real issue: `useViewedStories` updates `viewedPhotos` state which changes `viewedPhotoCount`. FeedScreen depends on `viewedPhotoCount`. But the render cycle might complete before the async Firestore persist triggers the state change.

Wait, looking at `markPhotosAsViewed` again:

```javascript
// Update ref immediately (sync) for instant access
const newSet = new Set([...viewedPhotosRef.current, ...photoIds]);
viewedPhotosRef.current = newSet;

// Update local state (async, triggers re-renders)
setViewedPhotos(newSet);
```

The state IS set synchronously via `setViewedPhotos(newSet)`. The Firestore persist is in background and doesn't affect local state.

So the state update should trigger re-render. Unless... the component unmounts/remounts during navigation?

Let me check: When PhotoDetailScreen is closed via navigation.goBack(), does FeedScreen unmount? No, it's still there in the stack.

OH! I see the issue now. When navigation.goBack() is called, the callback `onClose` fires, which calls `handleCloseMyStories`, which calls `markPhotosAsViewed`. But at this point, the navigation back is already happening.

The FeedScreen will re-render, but there might be a race condition where the navigation state change happens simultaneously with the viewed state change.

**Better fix:** Ensure the state update completes BEFORE navigation closes the modal. But we don't control the close timing - it comes from PhotoDetailScreen's back navigation.

Let me check if the order is: onClose callback -> navigation back happens -> FeedScreen visible again

Actually the order should be fine since onClose runs synchronously before the navigation completes.

**Debug first approach is best.** Let me write the task to add logging and then fix based on findings.
</action>
<verify>

1. Open own story (should start at first unviewed)
2. View all photos and close
3. Check logs for photo ID flow
4. Ring should change from purple to gray
5. Reopen - should start from photo 1 (all viewed)

For partial viewing:

1. View 2 of 5 photos, close
2. Ring should still be purple (not all viewed)
3. Reopen - should start at photo 3
   </verify>
   <done>Own story viewed state tracks correctly - ring updates and resume position works</done>
   </task>

<task type="auto">
  <name>Task 2: Fix reaction sorting by count (ISS-008)</name>
  <files>src/hooks/usePhotoDetailModal.js</files>
  <action>
The `orderedEmojis` memo in usePhotoDetailModal.js should sort reactions by count. Debug why sorting isn't working.

**Step 1: Add debug logging**

```javascript
const orderedEmojis = useMemo(() => {
  // Sort curated emojis by count
  const curatedData = curatedEmojis.map(emoji => ({
    emoji,
    totalCount: groupedReactions[emoji] || 0,
  }));

  // DEBUG: Log counts before sorting
  logger.debug('usePhotoDetailModal: orderedEmojis - counts', {
    curatedData: curatedData.map(d => `${d.emoji}:${d.totalCount}`),
  });

  const sortedCurated = [...curatedData]
    .sort((a, b) => b.totalCount - a.totalCount)
    .map(item => item.emoji);

  // DEBUG: Log sorted order
  logger.debug('usePhotoDetailModal: orderedEmojis - sorted', {
    sortedCurated,
    frozenOrder: frozenOrder ? 'FROZEN' : 'null',
  });

  const customToAdd = activeCustomEmojis.filter(e => !curatedEmojis.includes(e));

  if (frozenOrder) {
    const frozenCurated = frozenOrder.filter(e => curatedEmojis.includes(e));
    return [...customToAdd, ...frozenCurated];
  }

  return [...customToAdd, ...sortedCurated];
}, [frozenOrder, groupedReactions, curatedEmojis, activeCustomEmojis]);
```

**Step 2: Check if frozenOrder is persisting incorrectly**

The `frozenOrder` state should reset when:

1. Timer expires (1.5 seconds after last tap)
2. Photo changes (currentPhoto.id changes)
3. Modal closes and reopens

Add reset on photo change:

```javascript
// Reset frozenOrder when photo changes
useEffect(() => {
  setFrozenOrder(null);
}, [currentPhoto?.id]);
```

**Step 3: Check if groupedReactions has correct counts**

The `groupedReactions` memo aggregates counts:

```javascript
const groupedReactions = useMemo(() => {
  const grouped = {};
  Object.entries(reactions).forEach(([userId, userReactions]) => {
    if (typeof userReactions === 'object') {
      Object.entries(userReactions).forEach(([emoji, count]) => {
        if (!grouped[emoji]) {
          grouped[emoji] = 0;
        }
        grouped[emoji] += count;
      });
    }
  });
  return grouped;
}, [reactions]);
```

This looks correct. The data structure is `reactions[userId][emoji] = count`.

**Likely fix:** Add `frozenOrder` reset on photo change to ensure fresh sorting when switching photos.
</action>
<verify>

1. Open a story with reactions on photos
2. Verify emojis are sorted left-to-right by count (highest first)
3. Tap an emoji - order should freeze briefly
4. After 1.5s, order should re-sort with new counts
5. Switch to next photo - should show that photo's reactions sorted correctly
   </verify>
   <done>Reactions display sorted by count (highest to lowest, left to right)</done>
   </task>

<task type="auto">
  <name>Task 3: Clean up debug logging</name>
  <files>src/screens/FeedScreen.js, src/hooks/useViewedStories.js, src/hooks/usePhotoDetailModal.js</files>
  <action>
After fixing issues, remove or reduce debug logging added in Tasks 1-2.

Keep only essential logging that helps with future debugging:

- Key state transitions (opened/closed own stories)
- Error conditions

Remove verbose per-render logging that would spam production logs.
</action>
<verify>

1. App runs without excessive logging
2. Only meaningful debug messages remain
3. No performance impact from logging
   </verify>
   <done>Debug logging cleaned up, only essential logs remain</done>
   </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] ISS-006: Own story ring updates after viewing
- [ ] ISS-007: Own story resumes at correct position
- [ ] ISS-008: Reactions sorted by count (highest left)
- [ ] No console errors or warnings
- [ ] No excessive debug logging in production
</verification>

<success_criteria>

- All 3 issues from ISSUES.md resolved
- App runs without errors
- Ready for final re-verification
  </success_criteria>

<output>
After completion, create `.planning/phases/15.4-story-viewed-state-fix/15.4-02-FIX-SUMMARY.md`
</output>
