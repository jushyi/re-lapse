---
phase: 15-background-photo-upload
plan: 01
type: execute
---

<objective>
Implement async capture pipeline with background upload queue so photos save instantly and upload invisibly.

Purpose: Make the camera feel like a film camera - snap, done, ready for next shot. No waiting.
Output: CameraScreen captures photos instantly, uploads queue in background, enhanced drop animation provides tactile feedback.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-background-photo-upload/15-CONTEXT.md

**Key files:**
@src/screens/CameraScreen.js
@src/services/firebase/photoService.js
@src/services/firebase/storageService.js

**Prior decisions:**
- RN Firebase putFile pattern for uploads (efficient, no blob conversion)
- React Native Firebase SDK exclusively (no JS SDK)
- AsyncStorage for persistence

**Current flow problem:**
CameraScreen.takePicture() awaits createPhoto() which blocks while:
1. Creating Firestore document
2. Compressing image
3. Uploading to Storage
4. Updating Firestore with URL

Camera is blocked during entire upload. User cannot take another photo until upload completes.

**Target flow:**
1. Capture photo
2. Queue for background upload immediately
3. Play animation
4. Camera ready instantly
5. Upload happens invisibly in background
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create upload queue service with AsyncStorage persistence</name>
  <files>src/services/uploadQueueService.js</files>
  <action>
Create new uploadQueueService.js that manages a persistent upload queue:

**Queue Item Structure:**
```javascript
{
  id: string,           // UUID for queue item
  photoUri: string,     // Local file URI
  userId: string,       // User who captured
  createdAt: number,    // Timestamp
  attempts: number,     // Retry count
  status: 'pending' | 'uploading' | 'failed'
}
```

**Functions to implement:**

1. `initializeQueue()` - Load queue from AsyncStorage on app start, start processor
2. `addToQueue(userId, photoUri)` - Add item to queue, persist, trigger processor
3. `processQueue()` - Process items sequentially (not in parallel - avoid race conditions)
4. `uploadQueueItem(item)` - Do the actual upload:
   - Create Firestore doc (status: 'developing', imageURL: '')
   - Compress image
   - Upload to Storage
   - Update Firestore with URL
   - Initialize darkroom
   - On success: remove from queue
   - On failure: increment attempts, retry up to 3 times with exponential backoff
5. `getQueueLength()` - Return pending upload count (for potential UI indicator)
6. `clearFailedItems()` - Remove items that failed 3+ times (cleanup)

**Key patterns:**
- Use AsyncStorage key: `@uploadQueue`
- Queue processor is a singleton (only one processing at a time)
- Exponential backoff: 2s, 4s, 8s delays between retries
- Log all queue operations via logger utility
- Export individual functions, not a class

**Avoid:**
- Don't process multiple items simultaneously (race conditions with badge count)
- Don't block the queue processor - use try/catch per item
- Don't store the actual image data in AsyncStorage (just the URI path)
  </action>
  <verify>
- File exists at src/services/uploadQueueService.js
- All functions export correctly
- No syntax errors: `npx eslint src/services/uploadQueueService.js --no-eslintrc`
  </verify>
  <done>
- uploadQueueService.js created with initializeQueue, addToQueue, processQueue, uploadQueueItem, getQueueLength, clearFailedItems
- Uses AsyncStorage for persistence
- Implements exponential backoff retry (3 attempts max)
- Sequential processing (no parallel uploads)
  </done>
</task>

<task type="auto">
  <name>Task 2: Decouple CameraScreen capture from upload</name>
  <files>src/screens/CameraScreen.js, src/services/firebase/photoService.js</files>
  <action>
**Modify CameraScreen.js takePicture():**

1. Remove the `await createPhoto()` call that blocks camera
2. Instead, call `addToQueue(user.uid, photo.uri)` from uploadQueueService
3. Immediately set `isCapturing = false` after queueing (not after upload)
4. Animation already plays independently - keep that

New takePicture flow:
```javascript
const takePicture = async () => {
  if (!cameraRef.current || isCapturing || !user) return;

  try {
    setIsCapturing(true);

    const photo = await cameraRef.current.takePictureAsync({
      quality: 0.8,
      skipProcessing: true,
    });

    // Queue for background upload (non-blocking)
    addToQueue(user.uid, photo.uri);

    // Play animation
    playPhotoAnimation(photo.uri);

    // Optimistically update badge count (+1 developing)
    setDarkroomCounts(prev => ({
      ...prev,
      developingCount: prev.developingCount + 1,
      totalCount: prev.totalCount + 1,
    }));

    logger.info('CameraScreen: Photo queued for background upload');
  } catch (error) {
    logger.error('CameraScreen: Error capturing photo', error);
  } finally {
    setIsCapturing(false);
  }
};
```

**Add queue initialization on mount:**
```javascript
useEffect(() => {
  // Initialize upload queue on app start
  initializeQueue();
}, []);
```

**Import the new service:**
```javascript
import { addToQueue, initializeQueue } from '../services/uploadQueueService';
```

**Keep photoService.createPhoto() intact** - uploadQueueService will call it internally. Don't modify photoService.js yet - the queue service handles the orchestration.

**Avoid:**
- Don't await the addToQueue call
- Don't remove existing getDarkroomCounts polling (queue may complete between polls)
- Don't modify the animation - that's Task 3
  </action>
  <verify>
- Camera captures photo and returns to ready state immediately
- Badge count increments optimistically
- Background upload completes (check Firestore for new photo)
- No errors in console
  </verify>
  <done>
- takePicture() queues photo and releases camera immediately
- initializeQueue() called on mount
- Badge count updates optimistically
- Background upload works (verified by Firestore document appearing)
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance drop animation with physics and badge feedback</name>
  <files>src/screens/CameraScreen.js</files>
  <action>
**Enhance the existing playPhotoAnimation() with:**

1. **Flash effect on capture:**
   - Add a white overlay View that flashes briefly (100ms)
   - Animated opacity: 0 → 1 → 0 quickly
   - Simulates camera shutter flash

2. **Physics-based arc trajectory:**
   - Current animation: linear shrink + translate
   - New: Add curve to the path using spring animation
   - Photo should arc downward, not move in straight line
   - Use Animated.spring or cubic bezier interpolation

3. **Darkroom badge bounce on receipt:**
   - When photo animation reaches badge position, pulse the badge
   - Scale: 1 → 1.2 → 1 with spring
   - Requires adding Animated.Value to DarkroomButton
   - Trigger bounce when animation completes

**Implementation approach:**

For the arc, use quadratic bezier via intermediate positions:
```javascript
const photoTranslateX = animatedValue.interpolate({
  inputRange: [0, 0.3, 0.7, 1, 2],
  outputRange: [0, -40, SCREEN_WIDTH * 0.1, SCREEN_WIDTH * 0.25, SCREEN_WIDTH * 0.25],
});

const photoTranslateY = animatedValue.interpolate({
  inputRange: [0, 0.3, 0.7, 1, 2],
  outputRange: [0, -30, SCREEN_HEIGHT * 0.4, SCREEN_HEIGHT * 0.7, SCREEN_HEIGHT * 0.7],
});
```

For the flash:
```javascript
const [showFlash, setShowFlash] = useState(false);
const flashOpacity = useRef(new Animated.Value(0)).current;

const playFlashEffect = () => {
  setShowFlash(true);
  flashOpacity.setValue(0);
  Animated.sequence([
    Animated.timing(flashOpacity, { toValue: 0.8, duration: 50, useNativeDriver: true }),
    Animated.timing(flashOpacity, { toValue: 0, duration: 100, useNativeDriver: true }),
  ]).start(() => setShowFlash(false));
};
```

For badge bounce, pass a trigger function to DarkroomButton or use a shared animated value.

**Avoid:**
- Don't make animation too slow (total should be ~800ms max)
- Don't add haptics here - that's a separate phase
- Don't over-complicate the physics - subtle curve is better than exaggerated
  </action>
  <verify>
- Flash effect visible on capture (brief white overlay)
- Photo thumbnail arcs downward in a curve (not straight line)
- Darkroom badge bounces/pulses when photo "lands"
- Animation feels physical and satisfying
  </verify>
  <done>
- Flash effect shows on capture (100ms white flash)
- Photo arc animation with bezier-style curve
- Badge bounce animation on receipt
- Total animation time ~800ms
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Capture photo, camera ready immediately (no blocking)
- [ ] Photo appears in Firestore within a few seconds (background upload worked)
- [ ] Flash effect visible on capture
- [ ] Photo arcs down to darkroom badge (curved path)
- [ ] Badge bounces when receiving photo
- [ ] Close and reopen app - queued photos still upload (persistence works)
- [ ] Multiple rapid captures all queue and upload successfully
- [ ] No console errors during capture/upload flow
</verification>

<success_criteria>

- Camera releases immediately after capture (no wait for upload)
- Upload queue persists to AsyncStorage and survives app restart
- Failed uploads retry with exponential backoff
- Animation sequence: flash → arc → badge bounce
- All queued photos eventually appear in Firestore
- Badge count reflects queued photos optimistically
</success_criteria>

<output>
After completion, create `.planning/phases/15-background-photo-upload/15-01-SUMMARY.md`:

# Phase 15 Plan 01: Background Photo Upload Summary

**[One-liner about what shipped]**

## Accomplishments

- Created uploadQueueService for persistent background uploads
- Decoupled capture from upload in CameraScreen
- Enhanced drop animation with flash, arc, and badge bounce

## Files Created/Modified

- `src/services/uploadQueueService.js` - New upload queue service
- `src/screens/CameraScreen.js` - Async capture flow + enhanced animation

## Decisions Made

[Any implementation decisions]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for Phase 16: Camera Capture Feedback
</output>
