---
phase: 04.1-drag-reorder-visual-feedback
plan: 01-FIX
type: fix
---

<objective>
Fix 2 UAT issues from plan 04.1-01.

Source: 04.1-01-ISSUES.md
Priority: 0 critical, 2 major, 0 minor

**Root cause analysis:**
Both issues stem from React state updates (array reorder/deletion) happening before or during animation completion, causing React to re-render the component with new data while the old visual state briefly persists.

- **UAT-001 (flash on drop):** The withTiming callback triggers reorder, but the dragged item's visual position (translateX) resets to 0 when React re-renders with new array order, causing a flash to the "new" slot position before the item was visually there.

- **UAT-002 (no delete slide):** When deleting, handleRemovePhoto immediately updates the array. Items to the right don't animate because they're instantly re-keyed/re-rendered at new positions.
  </objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/4.1-drag-reorder-visual-feedback/04.1-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/4.1-drag-reorder-visual-feedback/04.1-01-PLAN.md

**Key file to modify:**
@src/screens/SelectsScreen.js

**Technical context:**

- react-native-reanimated shared values update on UI thread
- React state updates trigger re-render, resetting component instances
- photoId useEffect already attempts to reset animations on content change
- The issue is timing: animation completion callback runs, triggers state update, React re-renders before animation visually completes from user perspective

**Solution approach:**
Use LayoutAnimation for the array-level changes (reorder/delete) so React Native handles the transition between old and new layout positions, while keeping the per-item drag animations as-is.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix UAT-001 - Eliminate flash on drop with LayoutAnimation</name>
  <files>src/screens/SelectsScreen.js</files>
  <action>
Add LayoutAnimation to smooth the array reorder transition:

1. Import LayoutAnimation from react-native:

   ```javascript
   import { ..., LayoutAnimation, Platform, UIManager } from 'react-native';
   ```

2. Enable LayoutAnimation on Android (add near top of file, after imports):

   ```javascript
   if (Platform.OS === 'android' && UIManager.setLayoutAnimationEnabledExperimental) {
     UIManager.setLayoutAnimationEnabledExperimental(true);
   }
   ```

3. In handleReorder callback, trigger LayoutAnimation BEFORE state update:

   ```javascript
   const handleReorder = useCallback(
     (fromIndex, toIndex) => {
       logger.debug('SelectsScreen: Reordering photo', { fromIndex, toIndex });

       // Animate layout change to prevent flash
       LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

       setSelectedPhotos(prev => {
         const newPhotos = [...prev];
         const [movedItem] = newPhotos.splice(fromIndex, 1);
         newPhotos.splice(toIndex, 0, movedItem);
         return newPhotos;
       });
       // ... rest of selectedIndex logic
     },
     [selectedIndex]
   );
   ```

4. In DraggableThumbnail's onEnd handler for didReorder case, simplify:
   - Remove the translateX animation to target position (LayoutAnimation handles it)
   - Reset translateX/Y to 0 immediately
   - Call reorder and dragEnd directly (not in withTiming callback)

   ```javascript
   } else if (didReorder) {
     // Reset visual state - LayoutAnimation will handle the transition
     translateX.value = 0;
     translateY.value = 0;
     scale.value = withTiming(1, { duration: 150 });
     zIndex.value = 0;
     runOnJS(onHoverIndexChange)(null);
     runOnJS(onReorder)(index, targetIndex);
     runOnJS(onDragEnd)();
   }
   ```

The key insight: Don't animate the dragged item to target position manually. Let LayoutAnimation handle the entire layout transition when the array changes. This eliminates the race condition between animation completion and React re-render.
</action>
<verify>

1. Long-press and drag a thumbnail to a new position
2. Release the drag
3. Verify NO flash to old position - item should smoothly settle into new position
4. Verify the transition feels smooth (LayoutAnimation easeInEaseOut)
   </verify>
   <done>Dropping a dragged item settles smoothly into new position without any flash or jump</done>
   </task>

<task type="auto">
  <name>Task 2: Fix UAT-002 - Add slide animation when deleting</name>
  <files>src/screens/SelectsScreen.js</files>
  <action>
Add LayoutAnimation to handleRemovePhoto to animate remaining items sliding left:

1. In handleRemovePhoto callback, trigger LayoutAnimation BEFORE state update:

   ```javascript
   const handleRemovePhoto = useCallback(
     index => {
       logger.debug('SelectsScreen: Removing photo', { index });

       // Animate layout change so remaining items slide smoothly
       LayoutAnimation.configureNext(LayoutAnimation.Presets.easeInEaseOut);

       setSelectedPhotos(prev => {
         const newPhotos = prev.filter((_, i) => i !== index);
         // ... rest of selectedIndex logic
         return newPhotos;
       });
     },
     [selectedIndex]
   );
   ```

2. In DraggableThumbnail's onEnd handler for delete case, ensure clean state:
   - Reset all animation values to 0 immediately (no animation needed, LayoutAnimation handles it)
   - The existing code already resets values, just verify it's not animating them

This leverages the same LayoutAnimation pattern from Task 1. When a photo is deleted, LayoutAnimation will animate remaining items into their new positions.
</action>
<verify>

1. Navigate to SelectsScreen with 3+ photos
2. Drag a photo (not the rightmost one) to the delete bar
3. Release to delete
4. Verify remaining photos smoothly slide left to fill the gap (not snap)
   </verify>
   <done>After deleting a photo, remaining thumbnails smoothly slide left to fill the gap</done>
   </task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Fixed both UAT issues with LayoutAnimation for smooth array transitions</what-built>
  <how-to-verify>
    1. Run: npx expo start
    2. Navigate to SelectsScreen with 3+ photos

    **Test UAT-001 (drop flash):**
    3. Long-press and drag a thumbnail to a new position
    4. Release the drag
    5. Verify: Item settles smoothly into new position WITHOUT any flash/jump to old position
    6. Repeat several times to confirm consistency

    **Test UAT-002 (delete slide):**
    7. Drag a photo (not the rightmost) to the delete bar
    8. Release to delete
    9. Verify: Remaining photos smoothly SLIDE left (not snap) to fill the gap
    10. Repeat with different positions to confirm

    **Regression check:**
    11. Verify shift animations still work during drag (other items shift to show drop position)
    12. Verify gap still collapses when approaching delete zone

  </how-to-verify>
  <resume-signal>Type "approved" if both issues fixed, or describe remaining problems</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] UAT-001 fixed: No flash on drop
- [ ] UAT-002 fixed: Delete causes slide animation
- [ ] Shift animations during drag still work (regression check)
- [ ] Gap collapse toward delete zone still works (regression check)
- [ ] Overall drag-to-reorder feels smooth and polished
</verification>

<success_criteria>

- All UAT issues from 04.1-01-ISSUES.md addressed
- Both fixes verified working
- No regressions in existing drag-reorder functionality
- Ready for re-verification
  </success_criteria>

<output>
After completion, create `.planning/phases/4.1-drag-reorder-visual-feedback/04.1-01-FIX-SUMMARY.md`
</output>
