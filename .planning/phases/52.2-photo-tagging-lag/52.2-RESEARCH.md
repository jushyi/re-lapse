# Phase 52.2: Fix Photo Tagging Lag - ISS-016 - Research

**Researched:** 2026-02-13
**Domain:** Firestore real-time subscriptions, React state synchronization
**Confidence:** HIGH

<research_summary>

## Summary

Researched Firestore real-time subscription patterns and React state update best practices for fixing photo tag lag in React Native. The issue stems from a disconnect between Firestore data (ground truth) and local component state not updating when data changes.

The standard approach uses Firestore `onSnapshot()` listeners in `useEffect` hooks with proper cleanup, combined with FlatList `extraData` prop to trigger re-renders when external state changes. Common pitfalls include missing cleanup functions (memory leaks), stale closures (outdated state in callbacks), and FlatList not detecting data changes due to shallow equality checks.

**Primary recommendation:** Audit existing Firestore subscriptions for proper cleanup and dependency arrays, ensure FlatList components pass all render-dependent state via `extraData`, and verify state updates create new object references (not in-place mutations).
</research_summary>

<standard_stack>

## Standard Stack

### Core

| Library                          | Version | Purpose                        | Why Standard                                  |
| -------------------------------- | ------- | ------------------------------ | --------------------------------------------- |
| @react-native-firebase/firestore | Current | Firestore SDK for React Native | Official React Native Firebase implementation |
| react                            | 18+     | UI framework                   | Built-in state management and hooks           |
| react-native                     | Current | Mobile framework               | FlatList component for efficient lists        |

### Supporting

| Library | Version | Purpose                  | When to Use          |
| ------- | ------- | ------------------------ | -------------------- |
| N/A     | N/A     | This is a debugging task | Using existing stack |

### Alternatives Considered

| Instead of | Could Use                  | Tradeoff                                   |
| ---------- | -------------------------- | ------------------------------------------ |
| onSnapshot | Manual polling with getDoc | onSnapshot is real-time and more efficient |
| useState   | useReducer                 | useState is simpler for this use case      |
| FlatList   | ScrollView                 | FlatList optimizes for large lists         |

**Installation:**
No new packages needed - debugging existing implementation.
</standard_stack>

<architecture_patterns>

## Architecture Patterns

### Recommended Project Structure

```
src/
├── components/           # TagFriendsModal, TaggedPeopleModal
├── services/firebase/    # photoService with tag CRUD
├── hooks/               # Custom hooks for tag state
└── screens/             # Screens using tag components
```

### Pattern 1: Firestore Real-Time Subscription in useEffect

**What:** Subscribe to Firestore document/collection changes and update local state
**When to use:** Any time UI needs to reflect Firestore data in real-time
**Example:**

```javascript
// Source: React Native Firebase official docs
useEffect(() => {
  const subscriber = firestore()
    .collection('photos')
    .doc(photoId)
    .onSnapshot(documentSnapshot => {
      const data = documentSnapshot.data();
      setTaggedUsers(data?.taggedUsers || []);
    });

  // CRITICAL: Return cleanup function
  return () => subscriber();
}, [photoId]); // Include all dependencies
```

### Pattern 2: FlatList with extraData

**What:** Force FlatList to re-render when external state changes
**When to use:** When renderItem depends on state outside the data prop
**Example:**

```javascript
// Source: React Native official docs
const [selectedIds, setSelectedIds] = useState(new Set());

<FlatList
  data={friends}
  extraData={selectedIds} // Re-render when selection changes
  keyExtractor={item => item.userId}
  renderItem={({ item }) => {
    const isSelected = selectedIds.has(item.userId);
    return <FriendRow item={item} selected={isSelected} />;
  }}
/>;
```

### Pattern 3: Immutable State Updates

**What:** Always create new object/array references when updating state
**When to use:** Every state update in React
**Example:**

```javascript
// ❌ WRONG - Mutates in place, won't trigger re-render
taggedUsers.push(newUserId);
setTaggedUsers(taggedUsers);

// ✅ CORRECT - Creates new array reference
setTaggedUsers([...taggedUsers, newUserId]);

// ❌ WRONG - Mutates Set in place
selectedIds.add(userId);
setSelectedIds(selectedIds);

// ✅ CORRECT - Creates new Set
setSelectedIds(prev => {
  const next = new Set(prev);
  next.add(userId);
  return next;
});
```

### Anti-Patterns to Avoid

- **Missing cleanup in useEffect:** Forgetting to return unsubscribe function causes memory leaks and duplicate listeners
- **Stale closures:** Not including dependencies in useEffect array results in callbacks referencing outdated state
- **In-place mutations:** Modifying arrays/objects directly prevents React from detecting changes
- **Missing extraData:** FlatList won't re-render when external state changes
  </architecture_patterns>

<dont_hand_roll>

## Don't Hand-Roll

| Problem               | Don't Build                | Use Instead                | Why                                                          |
| --------------------- | -------------------------- | -------------------------- | ------------------------------------------------------------ |
| Real-time sync        | Manual polling with timers | Firestore onSnapshot       | Built-in change detection, efficient, handles offline/online |
| State updates         | Custom event emitters      | React useState/useReducer  | React reconciliation handles UI updates automatically        |
| List rendering        | Custom scroll view         | FlatList with extraData    | Virtualization, performance optimization built-in            |
| Memory leak detection | Manual tracking            | useEffect cleanup function | React handles cleanup lifecycle automatically                |

**Key insight:** React and Firestore SDK already solve real-time state sync. The bug is misusing these tools (missing cleanup, wrong dependencies, in-place mutations) - not a missing library.
</dont_hand_roll>

<common_pitfalls>

## Common Pitfalls

### Pitfall 1: Missing onSnapshot Cleanup Function

**What goes wrong:** Multiple listeners accumulate, causing duplicate updates and memory leaks
**Why it happens:** Forgetting to return unsubscribe function from useEffect
**How to avoid:** Always return cleanup function from useEffect
**Warning signs:** "Can't perform a React state update on an unmounted component" warning
**Example:**

```javascript
// ❌ WRONG - Memory leak
useEffect(() => {
  firestore()
    .collection('photos')
    .doc(photoId)
    .onSnapshot(snap => {
      setData(snap.data());
    });
  // Missing cleanup!
}, [photoId]);

// ✅ CORRECT
useEffect(() => {
  const unsubscribe = firestore()
    .collection('photos')
    .doc(photoId)
    .onSnapshot(snap => setData(snap.data()));

  return () => unsubscribe(); // Cleanup
}, [photoId]);
```

### Pitfall 2: Stale Closures in Callbacks

**What goes wrong:** Snapshot callbacks reference old state values from when effect was created
**Why it happens:** Missing dependencies in useEffect array or capturing state in closures
**How to avoid:** Include all referenced values in dependency array, or use functional state updates
**Warning signs:** State updates don't reflect current values, old data appears
**Example:**

```javascript
// ❌ WRONG - Stale closure
const [userId, setUserId] = useState('user1');

useEffect(() => {
  const unsubscribe = firestore()
    .collection('photos')
    .where('userId', '==', userId) // Captures initial userId
    .onSnapshot(snap => {
      /* ... */
    });

  return () => unsubscribe();
}, []); // Missing userId dependency!

// ✅ CORRECT
useEffect(() => {
  const unsubscribe = firestore()
    .collection('photos')
    .where('userId', '==', userId)
    .onSnapshot(snap => {
      /* ... */
    });

  return () => unsubscribe();
}, [userId]); // Include dependency
```

### Pitfall 3: FlatList Not Re-rendering with External State

**What goes wrong:** FlatList doesn't update when state outside data prop changes
**Why it happens:** FlatList is a PureComponent - shallow equality check on props
**How to avoid:** Pass all render-dependent state via extraData prop
**Warning signs:** Checkmarks don't appear, selections don't update visually
**Example:**

```javascript
// ❌ WRONG - FlatList won't re-render when selectedIds changes
<FlatList
  data={friends}
  renderItem={({item}) => {
    const isSelected = selectedIds.has(item.userId);
    return <Row selected={isSelected} />;
  }}
/>

// ✅ CORRECT
<FlatList
  data={friends}
  extraData={selectedIds} // Force re-render on change
  renderItem={({item}) => {
    const isSelected = selectedIds.has(item.userId);
    return <Row selected={isSelected} />;
  }}
/>
```

### Pitfall 4: In-Place State Mutations

**What goes wrong:** React doesn't detect state changes, UI doesn't update
**Why it happens:** Modifying state arrays/objects directly instead of creating new references
**How to avoid:** Always create new array/object references with spread operator
**Warning signs:** State changes but UI doesn't update, stale data persists
**Example:**

```javascript
// ❌ WRONG - Mutates in place
const handleTag = userId => {
  taggedUsers.push(userId);
  setTaggedUsers(taggedUsers); // Same reference!
};

// ✅ CORRECT - New array reference
const handleTag = userId => {
  setTaggedUsers([...taggedUsers, userId]);
};

// ✅ CORRECT - Functional update
const handleTag = userId => {
  setTaggedUsers(prev => [...prev, userId]);
};
```

### Pitfall 5: Local Cache vs Server Data Confusion

**What goes wrong:** onSnapshot triggers from local cache before server confirmation, causing flickering
**Why it happens:** Firestore returns cached data immediately, then server data when available
**How to avoid:** Check snapshot.metadata.fromCache or use metadata changes option
**Warning signs:** UI flickers or shows stale data briefly before updating
**Example:**

```javascript
// Detect cache vs server
onSnapshot(docRef, snapshot => {
  if (snapshot.metadata.fromCache) {
    logger.debug('From cache - may be stale');
  } else {
    logger.debug('From server - confirmed');
  }
  setData(snapshot.data());
});

// Listen to metadata changes (pending writes)
onSnapshot(docRef, { includeMetadataChanges: true }, snapshot => {
  const hasPendingWrites = snapshot.metadata.hasPendingWrites;
  logger.debug('Pending writes:', hasPendingWrites);
});
```

### Pitfall 6: useEffect Dependency Array Issues

**What goes wrong:** Effect doesn't re-run when dependencies change, or re-runs too often
**Why it happens:** Missing dependencies or unnecessary dependencies causing infinite loops
**How to avoid:** Include all values used inside effect, use useCallback for functions
**Warning signs:** Infinite re-renders, or subscriptions not updating
**Example:**

```javascript
// ❌ WRONG - Missing dependency
useEffect(() => {
  loadData(userId); // Uses userId but not in deps
}, []);

// ❌ WRONG - Function dependency causes re-runs
useEffect(() => {
  loadData();
}, [loadData]); // loadData recreated every render

// ✅ CORRECT - Include primitive dependency
useEffect(() => {
  loadData(userId);
}, [userId]);

// ✅ CORRECT - Wrap function in useCallback
const loadData = useCallback(() => {
  // ...
}, [userId]); // Only recreate when userId changes

useEffect(() => {
  loadData();
}, [loadData]);
```

</common_pitfalls>

<code_examples>

## Code Examples

Verified patterns from official sources:

### Complete Real-Time Subscription Pattern

```javascript
// Source: React Native Firebase docs
import { useEffect, useState } from 'react';
import { getFirestore } from '@react-native-firebase/firestore';

const usePhotoTags = photoId => {
  const [taggedUsers, setTaggedUsers] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    if (!photoId) return;

    const db = getFirestore();
    const unsubscribe = db
      .collection('photos')
      .doc(photoId)
      .onSnapshot(
        documentSnapshot => {
          const data = documentSnapshot.data();
          setTaggedUsers(data?.taggedUsers || []);
          setLoading(false);
        },
        error => {
          logger.error('usePhotoTags: Subscription error', { error: error.message });
          setLoading(false);
        }
      );

    // Cleanup on unmount or photoId change
    return () => unsubscribe();
  }, [photoId]);

  return { taggedUsers, loading };
};
```

### FlatList with Selection State

```javascript
// Source: React Native docs
const [friends, setFriends] = useState([]);
const [selectedIds, setSelectedIds] = useState(new Set());

const toggleFriend = useCallback(friendId => {
  setSelectedIds(prev => {
    const next = new Set(prev);
    if (next.has(friendId)) {
      next.delete(friendId);
    } else {
      next.add(friendId);
    }
    return next;
  });
}, []);

<FlatList
  data={friends}
  extraData={selectedIds} // CRITICAL for re-rendering
  keyExtractor={item => item.userId}
  renderItem={({ item }) => {
    const isSelected = selectedIds.has(item.userId);
    return (
      <TouchableOpacity onPress={() => toggleFriend(item.userId)}>
        <Text>{item.name}</Text>
        {isSelected && <PixelIcon name="checkmark" />}
      </TouchableOpacity>
    );
  }}
/>;
```

### Synchronizing Modal State with Firestore

```javascript
// Pattern: Modal re-opens with current Firestore data
const TagFriendsModal = ({ visible, photoId, onClose, onConfirm }) => {
  const [friends, setFriends] = useState([]);
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [currentTags, setCurrentTags] = useState([]);

  // Subscribe to photo's current tags
  useEffect(() => {
    if (!visible || !photoId) return;

    const unsubscribe = firestore()
      .collection('photos')
      .doc(photoId)
      .onSnapshot(snapshot => {
        const data = snapshot.data();
        const tags = data?.taggedUsers || [];
        setCurrentTags(tags);
        setSelectedIds(new Set(tags)); // Initialize with current tags
      });

    return () => unsubscribe();
  }, [visible, photoId]);

  // Toggle selection
  const toggleFriend = useCallback(friendId => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(friendId)) {
        next.delete(friendId);
      } else {
        next.add(friendId);
      }
      return next;
    });
  }, []);

  const handleConfirm = useCallback(() => {
    const ids = Array.from(selectedIds);
    onConfirm(ids);
  }, [selectedIds, onConfirm]);

  return (
    <Modal visible={visible} onRequestClose={onClose}>
      <FlatList
        data={friends}
        extraData={selectedIds}
        keyExtractor={item => item.userId}
        renderItem={({ item }) => {
          const isSelected = selectedIds.has(item.userId);
          return <FriendRow item={item} selected={isSelected} onToggle={toggleFriend} />;
        }}
      />
      <Button onPress={handleConfirm}>Done</Button>
    </Modal>
  );
};
```

</code_examples>

<sota_updates>

## State of the Art (2024-2026)

| Old Approach                            | Current Approach          | When Changed       | Impact                               |
| --------------------------------------- | ------------------------- | ------------------ | ------------------------------------ |
| Class components with componentDidMount | useEffect hook            | React 16.8+ (2019) | Simpler cleanup with return function |
| Manual listener tracking                | useEffect cleanup         | React 16.8+        | Automatic cleanup on unmount         |
| Redux for all state                     | useState for local state  | React 16.8+        | Less boilerplate for component state |
| shouldComponentUpdate                   | React.memo for components | React 16.8+        | Simpler memoization                  |

**New tools/patterns to consider:**

- **React 19 useEffectEvent (stable):** Solves stale closure issues by providing access to latest props/state without re-triggering effects. May help if closure issues persist.
- **Firestore metadata changes:** Use `{ includeMetadataChanges: true }` option to detect pending writes vs confirmed writes
- **React Compiler (experimental):** Auto-optimizes re-renders, but still requires correct state patterns

**Deprecated/outdated:**

- **Class component lifecycle methods:** Use useEffect instead
- **Manual subscription management outside React:** Let React handle with useEffect cleanup
- **Polling instead of onSnapshot:** Real-time listeners are more efficient
  </sota_updates>

<open_questions>

## Open Questions

1. **Current implementation details**
   - What we know: TagFriendsModal uses local state with initialSelectedIds prop
   - What's unclear: Where is initialSelectedIds sourced from? Is there a Firestore subscription updating it?
   - Recommendation: Audit the parent component to see if it subscribes to photo.taggedUsers in real-time

2. **Subscription lifecycle**
   - What we know: Must use onSnapshot with cleanup in useEffect
   - What's unclear: Are there existing subscriptions that aren't cleaning up properly?
   - Recommendation: Search codebase for `onSnapshot` calls and verify cleanup functions exist

3. **FlatList extraData usage**
   - What we know: FlatList needs extraData when renderItem depends on external state
   - What's unclear: Is extraData being passed in TagFriendsModal and other tag-related lists?
   - Recommendation: Check TagFriendsModal and TaggedPeopleModal FlatList props

4. **State propagation path**
   - What we know: Tags update in Firestore successfully (backend works)
   - What's unclear: Is the issue in the modal's local state, parent component state, or FlatList rendering?
   - Recommendation: Add debug logging at each state update point to trace where sync breaks
     </open_questions>

<sources>
## Sources

### Primary (HIGH confidence)

- [React Native Firebase Firestore Usage](https://rnfirebase.io/firestore/usage) - Real-time subscription patterns
- [Firebase Get Realtime Updates](https://firebase.google.com/docs/firestore/query-data/listen) - Official onSnapshot docs
- [React Native FlatList](https://reactnative.dev/docs/flatlist) - extraData prop and re-rendering behavior

### Secondary (MEDIUM confidence)

- [Firestore onSnapshot not working - GitHub Issue](https://github.com/firebase/firebase-js-sdk/issues/6023) - Common issues verified against docs
- [React Native Firebase Memory Leaks - GitHub Issue](https://github.com/invertase/react-native-firebase/issues/3038) - Cleanup patterns verified
- [FlatList Not Re-rendering - Brains & Beards](https://brainsandbeards.com/blog/2022-dont-rerender-all-flatlist-items/) - extraData pattern verified against official docs
- [React Stale Closures - TkDodo Blog](https://tkdodo.eu/blog/hooks-dependencies-and-stale-closures) - Verified dependency array patterns
- [React useEffectEvent Guide](https://peterkellner.net/2026/01/09/understanding-react-useeffectevent-vs-useeffect/) - New React 19 feature for solving closures

### Tertiary (LOW confidence - needs validation)

- None - all findings verified against official documentation

**Cross-verification notes:**

- All onSnapshot patterns verified against React Native Firebase official docs
- All FlatList extraData patterns verified against React Native official docs
- Memory leak prevention strategies verified against multiple GitHub issues and official docs
- Stale closure solutions verified against React documentation and community best practices
  </sources>

<metadata>
## Metadata

**Research scope:**

- Core technology: Firestore onSnapshot, React Native Firebase SDK
- Ecosystem: React hooks, FlatList, state management
- Patterns: Real-time subscription cleanup, FlatList re-rendering, immutable state updates
- Pitfalls: Memory leaks, stale closures, missing extraData, in-place mutations

**Confidence breakdown:**

- Standard stack: HIGH - Using existing React Native Firebase SDK
- Architecture: HIGH - Patterns from official docs (React Native Firebase, React, React Native)
- Pitfalls: HIGH - Documented in official docs and multiple verified GitHub issues
- Code examples: HIGH - From official React Native Firebase and React Native documentation

**Research date:** 2026-02-13
**Valid until:** 2026-03-13 (30 days - React/Firebase patterns are stable)

**Key diagnostic questions for planning:**

1. Does TagFriendsModal subscribe to photo.taggedUsers in real-time?
2. Is there an onSnapshot cleanup function for tag subscriptions?
3. Does FlatList in TagFriendsModal use extraData prop?
4. Are parent components passing fresh initialSelectedIds from Firestore subscriptions?
5. Are state updates creating new object references or mutating in place?
   </metadata>

---

_Phase: 52.2-photo-tagging-lag_
_Research completed: 2026-02-13_
_Ready for planning: yes_
