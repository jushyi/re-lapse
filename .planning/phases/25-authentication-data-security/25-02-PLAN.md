---
phase: 25-authentication-data-security
plan: 02
type: execute
---

<objective>
Implement Cloud Function for generating signed photo URLs with 24-hour expiration.

Purpose: Replace permanent download URLs with time-limited signed URLs for enhanced security. Even if a URL leaks, it expires within 24 hours.
Output: getSignedPhotoUrl callable Cloud Function, client-side signedUrlService for fetching signed URLs.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-authentication-data-security/25-RESEARCH.md
@.planning/phases/25-authentication-data-security/25-CONTEXT.md
@.planning/phases/25-authentication-data-security/25-01-SUMMARY.md

**Key files to modify:**
@functions/index.js
@functions/validation.js

**Tech stack available:**

- firebase-admin (existing in functions/)
- firebase-functions/v2/https (existing, onCall pattern)
- Zod validation (added in Phase 24)

**Established patterns from Phase 24:**

- Zod schemas for document validation
- validateOrNull helper for safe parsing
- Guard clauses with early returns
- firebase-functions.logger for structured logging

**Research findings to apply:**

- Use v4 signing (current standard)
- Maximum 7-day expiration (we'll use 24 hours)
- getSignedUrl from firebase-admin storage
- Require authentication (request.auth.uid check)
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add getSignedPhotoUrl Cloud Function</name>
  <files>functions/index.js, functions/validation.js</files>
  <action>
1. In `functions/validation.js`, add Zod schema for signed URL request:
```javascript
const SignedUrlRequestSchema = z.object({
  photoPath: z.string().min(1),
});
```
Export it alongside existing schemas.

2. In `functions/index.js`, add imports at top (if not already present):

```javascript
const { getStorage } = require('firebase-admin/storage');
const { onCall, HttpsError } = require('firebase-functions/v2/https');
```

3. Add getSignedPhotoUrl callable function:

```javascript
/**
 * Generate a signed URL for secure photo access with 24-hour expiration.
 * Requires authenticated user.
 */
exports.getSignedPhotoUrl = onCall(async request => {
  const userId = request.auth?.uid;

  // Guard: Require authentication
  if (!userId) {
    logger.warn('getSignedPhotoUrl: Unauthenticated request rejected');
    throw new HttpsError('unauthenticated', 'User must be authenticated');
  }

  // Validate request data
  const validationResult = SignedUrlRequestSchema.safeParse(request.data);
  if (!validationResult.success) {
    logger.warn('getSignedPhotoUrl: Invalid request data', {
      errors: validationResult.error.errors,
      userId,
    });
    throw new HttpsError('invalid-argument', 'Invalid request: photoPath is required');
  }

  const { photoPath } = validationResult.data;
  logger.info('getSignedPhotoUrl: Generating signed URL', { userId, photoPath });

  try {
    const bucket = getStorage().bucket();
    const file = bucket.file(photoPath);

    // Check if file exists
    const [exists] = await file.exists();
    if (!exists) {
      logger.warn('getSignedPhotoUrl: File not found', { photoPath, userId });
      throw new HttpsError('not-found', 'Photo not found');
    }

    // Generate signed URL with 24-hour expiration
    const [url] = await file.getSignedUrl({
      version: 'v4',
      action: 'read',
      expires: Date.now() + 24 * 60 * 60 * 1000, // 24 hours
    });

    logger.info('getSignedPhotoUrl: Signed URL generated', { userId, photoPath });
    return { url };
  } catch (error) {
    // Re-throw HttpsErrors as-is
    if (error instanceof HttpsError) {
      throw error;
    }
    logger.error('getSignedPhotoUrl: Failed to generate signed URL', {
      error: error.message,
      userId,
      photoPath,
    });
    throw new HttpsError('internal', 'Failed to generate signed URL');
  }
});
```

4. Add import for SignedUrlRequestSchema in index.js if not already importing from validation.js.

**AVOID:** Using v2 signing - use v4 per research.
**AVOID:** Expiration >7 days - v4 max is 7 days, we use 24 hours.
**AVOID:** Allowing unauthenticated access - always check request.auth.uid.
</action>
<verify>

- `cd functions && npm run lint` (if lint script exists) or manual review
- SignedUrlRequestSchema exists in validation.js
- getSignedPhotoUrl function exports correctly
- Uses v4 signing, 24-hour expiration
  </verify>
  <done>
- SignedUrlRequestSchema added to validation.js
- getSignedPhotoUrl Cloud Function added with auth check, validation, v4 signing
- 24-hour expiration configured
  </done>
  </task>

<task type="auto">
  <name>Task 2: Deploy and verify getSignedPhotoUrl function</name>
  <files>functions/index.js</files>
  <action>
1. Deploy to Firebase:
```bash
cd functions && npm install && firebase deploy --only functions:getSignedPhotoUrl
```

2. Verify deployment succeeded in output.

3. Test the function using Firebase Functions shell or curl (if testing infrastructure exists):
   - Function should reject unauthenticated calls
   - Function should reject calls without photoPath
   - Function should return signed URL for valid requests

Note: Full end-to-end testing requires authenticated client, which will happen naturally when client integration is added. For now, verify deployment succeeded.
</action>
<verify>

- Firebase deploy output shows success for getSignedPhotoUrl
- Function appears in Firebase Console under Functions
  </verify>
  <done>
- getSignedPhotoUrl deployed to Firebase
- Function visible in Firebase Console
  </done>
  </task>

<task type="auto">
  <name>Task 3: Create client-side signedUrlService</name>
  <files>src/services/firebase/signedUrlService.js</files>
  <action>
1. Create `src/services/firebase/signedUrlService.js`:
```javascript
import { getFunctions, httpsCallable } from '@react-native-firebase/functions';
import logger from '../../utils/logger';

// Initialize Functions
const functions = getFunctions();

/\*\*

- Get a signed URL for a photo with 24-hour expiration.
- @param {string} photoPath - Storage path to the photo (e.g., 'photos/abc123.jpg')
- @returns {Promise<{success: boolean, url?: string, error?: string}>}
  \*/
  export const getSignedPhotoUrl = async (photoPath) => {
  try {
  logger.debug('SignedUrlService.getSignedPhotoUrl: Requesting signed URL', { photoPath });

      const getSignedUrl = httpsCallable(functions, 'getSignedPhotoUrl');
      const result = await getSignedUrl({ photoPath });

      logger.info('SignedUrlService.getSignedPhotoUrl: Success', { photoPath });
      return { success: true, url: result.data.url };

  } catch (error) {
  logger.error('SignedUrlService.getSignedPhotoUrl: Failed', {
  photoPath,
  error: error.message,
  code: error.code
  });
  return { success: false, error: error.message };
  }
  };

/\*\*

- Convert a storage path to signed URL.
- Convenience function that extracts path from full URL if needed.
- @param {string} urlOrPath - Either a full storage URL or just the path
- @returns {Promise<{success: boolean, url?: string, error?: string}>}
  \*/
  export const convertToSignedUrl = async (urlOrPath) => {
  // If it's already a path (not a full URL), use directly
  let photoPath = urlOrPath;

// If it's a full Firebase Storage URL, extract the path
// URLs look like: https://firebasestorage.googleapis.com/v0/b/bucket/o/photos%2Fabc.jpg?...
if (urlOrPath.includes('firebasestorage.googleapis.com')) {
try {
const url = new URL(urlOrPath);
// Path is in the /o/ segment, URL-encoded
const pathMatch = url.pathname.match(/\/o\/(.+)$/);
if (pathMatch) {
photoPath = decodeURIComponent(pathMatch[1]);
}
} catch (e) {
logger.warn('SignedUrlService.convertToSignedUrl: Could not parse URL', { urlOrPath });
// Fall through and try with original value
}
}

return getSignedPhotoUrl(photoPath);
};

```

2. Export from services index if one exists, or leave as standalone import.

**Note:** This service is now available for components to use. Integration into existing components (FeedPhotoCard, PhotoDetailModal, etc.) that display photos is a separate concern - those components can optionally adopt signed URLs as needed, or this can be deferred if permanent URLs are acceptable for now (they still have security rules).
  </action>
  <verify>
- `npm run lint` passes
- signedUrlService.js exists with getSignedPhotoUrl and convertToSignedUrl
- Uses httpsCallable from @react-native-firebase/functions
  </verify>
  <done>
- signedUrlService.js created with two functions
- Ready for components to use for signed URL fetching
- Handles both paths and full URLs
  </done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] SignedUrlRequestSchema in validation.js
- [ ] getSignedPhotoUrl function in index.js with auth check, validation, v4 signing
- [ ] Function deployed to Firebase successfully
- [ ] signedUrlService.js exists on client with getSignedPhotoUrl and convertToSignedUrl
- [ ] `npm run lint` passes (client)
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Cloud Function deployed and working
- Client service ready for component integration
- Phase 25 complete
</success_criteria>

<output>
After completion, create `.planning/phases/25-authentication-data-security/25-02-SUMMARY.md`

This completes Phase 25. The signed URL infrastructure is in place. Components can adopt it as needed - existing permanent URLs continue working with security rules.
</output>
```
