---
phase: 08-user-albums
plan: 01
type: execute
---

<objective>
Create the album data layer with Firestore service for CRUD operations.

Purpose: Establish the data foundation that all album UI components will depend on.
Output: Working albumService.js with create, read, update, delete, and list operations.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./08-01-SUMMARY.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-user-albums/08-CONTEXT.md

@src/services/firebase/photoService.js
@src/services/firebase/index.js

**Tech stack available:** React Native, Firebase Firestore, existing service patterns
**Established patterns:** Service returns `{ success: true, data }` or `{ success: false, error }`

**Album data model (from context):**

- Album belongs to a user (userId)
- Album has: id, name (max 24 chars), coverPhotoId, photoIds array, createdAt, updatedAt
- Photos ordered newest first within albums
- Albums ordered by updatedAt (most recently modified first)
- Cover photo must be from photos in that album
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create albumService.js with CRUD operations</name>
  <files>src/services/firebase/albumService.js</files>
  <action>
Create albumService.js following existing service patterns (see photoService.js).

Functions to implement:

1. `createAlbum(userId, name, photoIds)` - Create new album with name and initial photos. First photo becomes cover. Returns `{ success, album }`.
2. `getAlbum(albumId)` - Get single album by ID. Returns `{ success, album }`.
3. `getUserAlbums(userId)` - Get all albums for user, ordered by updatedAt desc. Returns `{ success, albums }`.
4. `updateAlbum(albumId, updates)` - Update album fields (name, coverPhotoId). Sets updatedAt. Returns `{ success }`.
5. `deleteAlbum(albumId)` - Delete album (photos remain in app). Returns `{ success }`.
6. `addPhotosToAlbum(albumId, photoIds)` - Add photos to existing album. Sets updatedAt. Returns `{ success }`.
7. `removePhotoFromAlbum(albumId, photoId)` - Remove single photo. If last photo, return warning. If removing cover, set new cover to first remaining photo. Returns `{ success, warning? }`.
8. `setCoverPhoto(albumId, photoId)` - Set album cover (must be photo in album). Returns `{ success }`.

Album document structure in Firestore `albums` collection:

```
{
  userId: string,
  name: string,
  coverPhotoId: string,
  photoIds: string[],
  createdAt: Timestamp,
  updatedAt: Timestamp
}
```

Use logger for all operations. Validate inputs (name required, max 24 chars, at least 1 photo on create).
</action>
<verify>Import and call `getUserAlbums('test-user')` - should return `{ success: true, albums: [] }`</verify>
<done>All 8 functions implemented with proper error handling and logging</done>
</task>

<task type="auto">
  <name>Task 2: Export albumService from services index</name>
  <files>src/services/firebase/index.js</files>
  <action>
Add albumService to the barrel export file:
1. Import all exports from albumService
2. Re-export them

Follow the existing pattern in the file for other services.
</action>
<verify>Can import `{ createAlbum, getUserAlbums }` from `../services/firebase`</verify>
<done>albumService functions available via barrel export</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] albumService.js exists with all 8 functions
- [ ] All functions follow `{ success, data/error }` pattern
- [ ] Logger calls present for debug/info/error
- [ ] Input validation for name length and required fields
- [ ] Service exported from index.js
- [ ] No TypeScript/lint errors: `npm run lint`
</verification>

<success_criteria>

- All CRUD operations implemented
- Service follows existing codebase patterns
- Functions handle edge cases (empty albums, removing last photo, etc.)
- Ready for UI components to consume
  </success_criteria>

<output>
After completion, create `.planning/phases/08-user-albums/08-01-SUMMARY.md`
</output>
