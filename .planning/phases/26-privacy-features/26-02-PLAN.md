---
phase: 26-privacy-features
plan: 02
type: execute
---

<objective>
Implement account deletion with phone re-authentication, Cloud Function cascade deletion, and client service.

Purpose: Meet App Store requirement for in-app account deletion with proper security (re-authentication) and complete data cleanup.
Output: DeleteAccountScreen with re-auth flow, deleteUserAccount Cloud Function, accountService client.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/26-privacy-features/26-CONTEXT.md
@.planning/phases/26-privacy-features/26-RESEARCH.md
@.planning/phases/26-privacy-features/26-01-SUMMARY.md (if exists)

# Prior phase context:

@.planning/phases/25-authentication-data-security/25-01-SUMMARY.md

# Source files:

@functions/index.js
@src/services/firebase/signedUrlService.js (httpsCallable pattern)
@src/context/PhoneAuthContext.js
@src/services/firebase/phoneAuthService.js
@src/screens/VerificationScreen.js (re-auth UI pattern)
@src/context/AuthContext.js

**Tech stack available:**

- @react-native-firebase/auth (phone re-authentication)
- @react-native-firebase/functions (httpsCallable)
- firebase-admin (batch operations, storage deletion)
- PhoneAuthContext for verification flow

**Established patterns:**

- httpsCallable pattern from signedUrlService.js
- Phone verification flow from PhoneAuthContext/VerificationScreen
- Secure logout from AuthContext (6-step cleanup)
- Zod validation schemas in functions/validation.js
- Guard clauses with null returns for background triggers

**Constraining decisions:**

- Phase 26 CONTEXT: Re-authentication required before deletion
- Phase 26 CONTEXT: Full data purge on deletion (photos, friendships, darkroom, user doc)
- Phase 26 RESEARCH: Delete Firestore data BEFORE deleting auth user (maintains permissions)
- Phase 26 RESEARCH: Query friendships twice (user1Id OR user2Id) to catch all
- Phase 26 RESEARCH: Delete Storage files before Firestore documents
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create deleteUserAccount Cloud Function</name>
  <files>functions/index.js</files>
  <action>
    Add deleteUserAccount callable function to functions/index.js:

    1. Add the function after existing exports (before final closing):

       /**
        * Delete user account and all associated data
        * Called after user re-authenticates via phone verification
        * Order: Storage files -> Photos -> Friendships -> Darkroom -> User -> Auth
        */
       exports.deleteUserAccount = onCall({ cors: true }, async (request) => {
         // Require authentication
         if (!request.auth) {
           throw new HttpsError('unauthenticated', 'Must be authenticated to delete account');
         }

         const userId = request.auth.uid;
         logger.info('deleteUserAccount: Starting deletion', { userId });

         try {
           const db = admin.firestore();
           const bucket = getStorage().bucket();

           // Step 1: Get all user's photos and delete Storage files
           const photosSnapshot = await db.collection('photos').where('userId', '==', userId).get();
           logger.info('deleteUserAccount: Found photos to delete', { count: photosSnapshot.size });

           for (const doc of photosSnapshot.docs) {
             const photoData = doc.data();
             if (photoData.imageURL) {
               try {
                 // Extract path from Firebase Storage URL
                 const decodedUrl = decodeURIComponent(photoData.imageURL);
                 const pathMatch = decodedUrl.match(/\/o\/(.+?)\?/);
                 if (pathMatch) {
                   await bucket.file(pathMatch[1]).delete();
                   logger.debug('deleteUserAccount: Deleted storage file', { path: pathMatch[1] });
                 }
               } catch (storageError) {
                 // Log but continue - file may already be deleted
                 logger.warn('deleteUserAccount: Storage file deletion failed', { error: storageError.message });
               }
             }
           }

           // Step 2: Delete all photos from Firestore (batch, max 500)
           const photoBatch = db.batch();
           photosSnapshot.docs.forEach(doc => photoBatch.delete(doc.ref));
           if (photosSnapshot.size > 0) {
             await photoBatch.commit();
             logger.info('deleteUserAccount: Deleted photo documents', { count: photosSnapshot.size });
           }

           // Step 3: Delete friendships where user is user1Id
           const friendships1 = await db.collection('friendships').where('user1Id', '==', userId).get();
           const friendship1Batch = db.batch();
           friendships1.docs.forEach(doc => friendship1Batch.delete(doc.ref));
           if (friendships1.size > 0) {
             await friendship1Batch.commit();
             logger.info('deleteUserAccount: Deleted friendships (user1)', { count: friendships1.size });
           }

           // Step 4: Delete friendships where user is user2Id
           const friendships2 = await db.collection('friendships').where('user2Id', '==', userId).get();
           const friendship2Batch = db.batch();
           friendships2.docs.forEach(doc => friendship2Batch.delete(doc.ref));
           if (friendships2.size > 0) {
             await friendship2Batch.commit();
             logger.info('deleteUserAccount: Deleted friendships (user2)', { count: friendships2.size });
           }

           // Step 5: Delete darkroom document
           const darkroomRef = db.doc(`darkrooms/${userId}`);
           const darkroomDoc = await darkroomRef.get();
           if (darkroomDoc.exists) {
             await darkroomRef.delete();
             logger.info('deleteUserAccount: Deleted darkroom document');
           }

           // Step 6: Delete user document
           const userRef = db.doc(`users/${userId}`);
           const userDoc = await userRef.get();
           if (userDoc.exists) {
             await userRef.delete();
             logger.info('deleteUserAccount: Deleted user document');
           }

           // Step 7: Delete Firebase Auth user (LAST - after all data cleanup)
           await admin.auth().deleteUser(userId);
           logger.info('deleteUserAccount: Deleted auth user, account deletion complete', { userId });

           return { success: true };
         } catch (error) {
           logger.error('deleteUserAccount: Failed', { userId, error: error.message });
           throw new HttpsError('internal', 'Account deletion failed: ' + error.message);
         }
       });

    NOTE: This handles the "delete auth user LAST" requirement from research pitfalls.
    NOTE: Uses two queries for friendships to handle deterministic ID pattern (user can be user1Id OR user2Id).

  </action>
  <verify>cd functions && npm run lint (or node --check index.js if no lint script)</verify>
  <done>deleteUserAccount Cloud Function added with cascade deletion in correct order</done>
</task>

<task type="auto">
  <name>Task 2: Create DeleteAccountScreen with re-authentication flow</name>
  <files>src/screens/DeleteAccountScreen.js, src/services/firebase/accountService.js</files>
  <action>
    1. Create src/services/firebase/accountService.js:
       - Import functions from @react-native-firebase/functions
       - Export deleteUserAccount function that calls httpsCallable('deleteUserAccount')
       - Follow pattern from signedUrlService.js
       - Return { success: boolean, error?: string }

    2. Create DeleteAccountScreen.js with multi-step flow:

       Step 1 (initial): Warning screen
       - Dark theme (backgroundColor: '#000000')
       - Warning icon (⚠️ or Ionicons warning-outline in red)
       - Title: "Delete Account"
       - Warning text explaining what will be deleted:
         "This will permanently delete:
         • All your photos
         • Your friend connections
         • Your profile and account data

         This action cannot be undone."
       - "I understand, delete my account" button (red, outline style)
       - "Cancel" button (returns to Settings)

       Step 2 (verification): Re-authentication
       - Reuse phone verification UI pattern from VerificationScreen
       - Show message: "For security, please verify your phone number"
       - Display user's phone number from auth().currentUser.phoneNumber
       - "Send Verification Code" button
       - Use phoneAuthService.sendVerificationCode() with user's existing phone
       - On success, show code input (6-digit OTP field)
       - Auto-submit on 6 digits entered

       Step 3 (deleting): Progress indicator
       - Show ActivityIndicator with "Deleting account..." message
       - Call accountService.deleteUserAccount()
       - On success, user is automatically signed out (auth user deleted server-side)
       - On error, show Alert with error message and return to step 1

       Use PhoneAuthContext for verification state management (setConfirmation, etc.)
       Use useState for step tracking: 'warning' | 'verify' | 'code' | 'deleting'

  </action>
  <verify>node --check src/services/firebase/accountService.js && node --check src/screens/DeleteAccountScreen.js</verify>
  <done>DeleteAccountScreen handles full flow: warning -> re-auth -> deletion with proper error handling</done>
</task>

<task type="auto">
  <name>Task 3: Wire DeleteAccount screen into navigation and deploy function</name>
  <files>src/navigation/AppNavigator.js</files>
  <action>
    1. Update AppNavigator.js:
       - Import DeleteAccountScreen: import DeleteAccountScreen from '../screens/DeleteAccountScreen';
       - Add to ProfileStackNavigator after TermsOfService:
         <Stack.Screen name="DeleteAccount" component={DeleteAccountScreen} />

    2. Update SettingsScreen.js (if needed):
       - Ensure Delete Account menu item navigates to 'DeleteAccount' screen (not showing alert)
       - Should already be set up from Plan 01, but verify it navigates: navigation.navigate('DeleteAccount')

    3. Deploy Cloud Function:
       - Run: firebase deploy --only functions:deleteUserAccount
       - Verify function appears in Firebase Console

    4. Update src/services/firebase/index.js to export accountService:
       - Add: export * from './accountService';

  </action>
  <verify>firebase deploy --only functions:deleteUserAccount && npm run lint -- --quiet src/navigation/AppNavigator.js</verify>
  <done>DeleteAccount screen accessible from Settings, Cloud Function deployed</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run lint` passes without errors
- [ ] Cloud Function deployed: `firebase functions:list` shows deleteUserAccount
- [ ] App navigates: Settings -> Delete Account shows warning screen
- [ ] Warning screen explains what will be deleted
- [ ] Cancel button returns to Settings
- [ ] "I understand" button advances to verification step
- [ ] Verification sends SMS to user's phone number
- [ ] Code entry triggers account deletion on valid code
- [ ] After deletion, user is signed out and returned to login screen
- [ ] All user data actually deleted (test with Firebase Console)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No lint errors
- Account deletion flow works end-to-end
- Re-authentication prevents unauthorized deletion
- All user data (photos, friendships, darkroom, user doc) deleted
- Storage files deleted (no orphaned blobs)
- Phase 26 complete - ready for App Store submission
  </success_criteria>

<output>
After completion, create `.planning/phases/26-privacy-features/26-02-SUMMARY.md`
</output>
