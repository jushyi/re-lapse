---
phase: 24-cloud-functions-validation
plan: 01
type: execute
---

<objective>
Add input validation and consistent error handling to Cloud Functions using Zod schemas.

Purpose: Defensive coding layer to catch malformed data and ensure graceful failure in all trigger functions.
Output: Validated, robust Cloud Functions with Zod schemas and centralized error handling.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-cloud-functions-validation/24-CONTEXT.md
@.planning/phases/24-cloud-functions-validation/24-RESEARCH.md
@.planning/phases/23-firestore-security-rules-audit/23-01-SUMMARY.md
@functions/index.js
@functions/logger.js
@functions/package.json

**Phase 23 provides:**

- Firestore Security Rules with field-level validation
- Self-reaction prevention at database level
- Immutable field protection for photos

**Phase 24 adds:**

- Schema validation for trigger data shapes
- Consistent error handling patterns
- Guard clauses with early returns

**Research findings:**

- Use Zod for type-safe schema validation
- Background triggers should never throw (return null instead)
- Don't over-validate - Security Rules already enforce access control
- Focus on data shape/type checking, not auth (triggers lack context.auth)

**Decisions from CONTEXT.md:**

- "Trust but verify" approach - validate to catch mistakes, not assume malice
- Keep it simple - no rate limiting needed for friends-only app
- No function refactoring - just add validation to existing code
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add Zod and create validation schemas</name>
  <files>functions/package.json, functions/validation.js</files>
  <action>
1. Install Zod in functions directory:
   ```bash
   cd functions && npm install zod
   ```

2. Create `functions/validation.js` with Zod schemas for Firestore document shapes:
   - **DarkroomDocSchema**: userId (string), nextRevealAt (any - Timestamp), lastRevealedAt (any, nullable), lastNotifiedAt (any, optional)

   - **PhotoDocSchema**: userId (string min 1), imageURL (string url), capturedAt (any), revealedAt (any nullable), status (enum: developing/revealed/triaged), photoState (enum: journal/archive, nullable), reactions (record of records, optional), reactionCount (number int min 0)

   - **FriendshipDocSchema**: user1Id (string min 1), user2Id (string min 1), status (enum: pending/accepted), requestedBy (string min 1), createdAt (any), acceptedAt (any, optional)

   - **UserDocSchema**: displayName (string, optional), username (string, optional), fcmToken (string, optional), profilePhotoURL (string url, optional)

3. Export helper function `validateOrNull(schema, data, context)` that:
   - Uses safeParse to validate data
   - Logs warning with context if validation fails
   - Returns validated data or null

Note: Use `z.any()` for Firestore Timestamps - they don't serialize to JSON cleanly. The goal is shape validation, not deep type enforcement on Firebase-specific types.
</action>
<verify>

1. `cat functions/package.json | grep zod` shows zod in dependencies
2. `node -e "require('./functions/validation.js')"` runs without error
   </verify>
   <done>Zod installed, validation.js exists with schemas for darkroom, photo, friendship, and user documents, plus validateOrNull helper</done>
   </task>

<task type="auto">
  <name>Task 2: Add validation and error handling to Cloud Functions</name>
  <files>functions/index.js</files>
  <action>
Apply validation and error handling patterns to all 4 exported functions:

1. **Add imports at top:**

   ```javascript
   const {
     validateOrNull,
     DarkroomDocSchema,
     PhotoDocSchema,
     FriendshipDocSchema,
     UserDocSchema,
   } = require('./validation');
   ```

2. **processDarkroomReveals (scheduled):**
   - Already has good try/catch structure - no changes needed
   - Logging is adequate

3. **sendPhotoRevealNotification (onUpdate):**
   - Add guard clause: validate `after` data exists
   - Add guard clause: validate `before` data exists
   - Use existing timestamp checks (already good)
   - Keep existing try/catch pattern

4. **sendFriendRequestNotification (onCreate):**
   - Add guard at top: validate friendshipData with FriendshipDocSchema
   - If validation fails, log warning and return null
   - Add guard: verify requestedBy, user1Id, user2Id are all present and different from each other
   - Keep existing status check

5. **sendReactionNotification (onUpdate):**
   - Add guard at top: validate `after` data has required fields
   - Add guard: ensure `before` exists
   - Keep existing reaction diff logic

6. **sendPushNotification (helper):**
   - Already validates token format - no changes needed

7. **revealUserPhotos (helper):**
   - Add guard: validate userId is non-empty string
   - Already has good logging

Pattern to apply consistently:

```javascript
// Guard: validate data
if (!after || typeof after !== 'object') {
  logger.warn('functionName: Invalid document data', { docId: context.params.docId });
  return null;
}
```

DO NOT refactor existing logic - only ADD validation guards at entry points.
</action>
<verify>

1. `node -e "require('./functions/index.js')"` runs without error (syntax check)
2. All 4 exported functions have validation guards at their entry points
3. No functions throw errors - all use return null pattern
   </verify>
   <done>All trigger functions have entry-point validation with consistent guard clause pattern, all error paths return null</done>
   </task>

<task type="auto">
  <name>Task 3: Deploy and verify Cloud Functions</name>
  <files>functions/index.js</files>
  <action>
1. Deploy functions to Firebase:
   ```bash
   cd functions && npm run deploy
   ```

2. Verify deployment succeeded with no errors

3. Check Firebase console for function health (optional - can skip if deploy succeeds)

Note: No changes to existing functionality - validation only adds guards, doesn't change behavior for valid data.
</action>
<verify>

1. `firebase deploy --only functions` completes successfully
2. No deployment errors in output
   </verify>
   <done>Cloud Functions deployed successfully with validation, no deployment errors</done>
   </task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] `npm ls zod` in functions directory shows zod installed
- [ ] `node -e "require('./functions/validation.js')"` passes
- [ ] `node -e "require('./functions/index.js')"` passes
- [ ] Functions deploy without errors
- [ ] No changes to existing function behavior (validation only adds guards)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Zod schemas created for 4 document types
- All 4 exported Cloud Functions have validation guards
- Functions deploy successfully to Firebase
- No breaking changes to existing functionality
  </success_criteria>

<output>
After completion, create `.planning/phases/24-cloud-functions-validation/24-01-SUMMARY.md` with:

# Phase 24 Plan 01: Cloud Functions Validation Summary

**[Substantive one-liner describing what was accomplished]**

## Performance

- Duration: X min
- Tasks: 3
- Files modified: 3 (package.json, validation.js, index.js)

## Accomplishments

- [Key outcomes]

## Files Created/Modified

- `functions/package.json` - Added zod dependency
- `functions/validation.js` - Created with Zod schemas
- `functions/index.js` - Added validation guards to all functions

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 24 complete, ready for Phase 25 (Authentication and Data Security).
</output>
