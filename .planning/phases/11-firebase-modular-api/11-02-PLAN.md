---
phase: 11-firebase-modular-api
plan: 02
type: execute
---

<objective>
Migrate social services (feed and friendship) from namespaced to modular Firestore API.

Purpose: Continue modular API migration for services with complex queries including Filter.or patterns.
Output: feedService.js and friendshipService.js using modular imports with Filter compatibility.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/11-firebase-modular-api/11-01-SUMMARY.md
@src/services/firebase/feedService.js
@src/services/firebase/friendshipService.js

**Migration Pattern Reference (from 11-01):**

```javascript
import { getFirestore, collection, doc, getDoc, getDocs, updateDoc, query, where, orderBy, onSnapshot, serverTimestamp } from '@react-native-firebase/firestore';
const db = getFirestore();
```

**Filter.or Pattern:**
The `Filter` import remains the same for OR queries:
```javascript
import { getFirestore, ..., Filter } from '@react-native-firebase/firestore';

// Usage stays same
query(collection(db, 'friendships'),
  where(Filter.or(
    Filter.where('user1Id', '==', userId),
    Filter.where('user2Id', '==', userId)
  )),
  where('status', '==', 'accepted')
)
```

**Real-time Listeners Pattern:**
```javascript
// Namespaced
firestore().collection('x').where(...).onSnapshot(callback)

// Modular
const q = query(collection(db, 'x'), where(...));
onSnapshot(q, callback)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate feedService.js to modular Firestore API</name>
  <files>src/services/firebase/feedService.js</files>
  <action>
Transform all Firestore operations to modular API pattern:

1. Update imports:
   - Remove: `import firestore from '@react-native-firebase/firestore'`
   - Add: `import { getFirestore, collection, doc, getDoc, getDocs, updateDoc, query, where, orderBy, onSnapshot, runTransaction } from '@react-native-firebase/firestore'`

2. Initialize Firestore once at module level:
   - Add: `const db = getFirestore();`

3. Transform each function:

   **getFeedPhotos:**
   - `firestore().collection('photos').where(...).orderBy(...).get()` →
     `getDocs(query(collection(db, 'photos'), where('photoState', '==', 'journal'), orderBy('capturedAt', 'desc')))`
   - `firestore().collection('users').doc(id).get()` → `getDoc(doc(db, 'users', id))`
   - Update exists check: use `docSnap.exists` (property)

   **subscribeFeedPhotos:**
   - Create query: `const q = query(collection(db, 'photos'), where('photoState', '==', 'journal'), orderBy('capturedAt', 'desc'))`
   - `firestore().collection(...).onSnapshot()` → `onSnapshot(q, callback)`
   - Return unsubscribe function directly (onSnapshot returns it)

   **getPhotoById:**
   - `firestore().collection('photos').doc(id).get()` → `getDoc(doc(db, 'photos', id))`
   - `firestore().collection('users').doc(id).get()` → `getDoc(doc(db, 'users', id))`

   **getUserFeedPhotos:**
   - Same query transformation pattern

   **getFeedStats:**
   - Multiple query transformations, same pattern

   **toggleReaction:**
   - `firestore().collection('photos').doc(id)` → `doc(db, 'photos', id)`
   - `firestore().runTransaction()` → `runTransaction(db, async (transaction) => {...})`
   - Inside transaction: `transaction.get(ref)` stays same
   - `transaction.update(ref, data)` stays same
   - Update exists check: use `docSnap.exists` (property)

Keep all logging, error handling, and return patterns identical.
  </action>
  <verify>Run the app, open Feed tab, verify photos load correctly, test reactions work</verify>
  <done>feedService.js uses only modular imports, feed and reactions functional, no namespaced API usage</done>
</task>

<task type="auto">
  <name>Task 2: Migrate friendshipService.js to modular Firestore API</name>
  <files>src/services/firebase/friendshipService.js</files>
  <action>
Transform all Firestore operations to modular API pattern:

1. Update imports:
   - Remove: `import firestore, { Filter } from '@react-native-firebase/firestore'`
   - Add: `import { getFirestore, collection, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, query, where, onSnapshot, serverTimestamp, Filter } from '@react-native-firebase/firestore'`

2. Initialize Firestore once at module level:
   - Add: `const db = getFirestore();`

3. Transform each function:

   **generateFriendshipId:**
   - No changes (pure JS function)

   **sendFriendRequest:**
   - `firestore().collection('friendships').doc(id)` → `doc(db, 'friendships', id)`
   - `ref.get()` → `getDoc(ref)`
   - `ref.set(data)` → `setDoc(ref, data)`
   - `firestore.FieldValue.serverTimestamp()` → `serverTimestamp()`

   **acceptFriendRequest:**
   - `firestore().collection('friendships').doc(id)` → `doc(db, 'friendships', id)`
   - `ref.get()` → `getDoc(ref)`
   - `ref.update(data)` → `updateDoc(ref, data)`
   - `firestore.FieldValue.serverTimestamp()` → `serverTimestamp()`

   **declineFriendRequest:**
   - Same pattern, uses delete: `ref.delete()` → `deleteDoc(ref)`

   **removeFriend:**
   - Same pattern as declineFriendRequest

   **getFriendships:**
   - `firestore().collection('friendships').where(Filter.or(...)).where(...).get()` →
     `getDocs(query(collection(db, 'friendships'), where(Filter.or(Filter.where('user1Id', '==', userId), Filter.where('user2Id', '==', userId))), where('status', '==', 'accepted')))`
   - Note: Filter.or usage stays exactly the same

   **getPendingRequests:**
   - Same pattern with Filter.or for OR query

   **getSentRequests:**
   - Same pattern with Filter.or

   **checkFriendshipStatus:**
   - `firestore().collection('friendships').doc(id)` → `doc(db, 'friendships', id)`
   - `ref.get()` → `getDoc(ref)`

   **subscribeFriendships:**
   - Create query: `const q = query(collection(db, 'friendships'), where(Filter.or(...)), where('status', '==', 'accepted'))`
   - `firestore().collection(...).onSnapshot()` → `onSnapshot(q, callback)`

   **getFriendUserIds:**
   - Reuses getFriendships, no direct Firestore calls

IMPORTANT: The Filter.or pattern established in Phase 9 works the same way with modular API - just ensure Filter is imported alongside other functions.

Keep all logging, error handling, and return patterns identical.
  </action>
  <verify>Run the app, check Friends tab loads, verify friend requests work, test friend removal</verify>
  <done>friendshipService.js uses only modular imports including Filter, all friendship operations functional, no namespaced API usage</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm start` runs without errors
- [ ] No "This method is deprecated" warnings for Firestore operations in feedService or friendshipService
- [ ] Feed loads with friends' photos
- [ ] Reactions work (tap emoji, count updates)
- [ ] Real-time feed updates work (subscribeFeedPhotos)
- [ ] Friends list loads correctly
- [ ] Friend requests can be sent/accepted/declined
- [ ] Real-time friendship updates work (subscribeFriendships)
</verification>

<success_criteria>

- Both feedService.js and friendshipService.js use modular imports only
- Filter.or pattern works correctly with modular API
- Real-time listeners (onSnapshot) work with modular pattern
- Transactions work with modular runTransaction
- All feed and friendship operations functional
- Deprecation warnings eliminated for these services
  </success_criteria>

<output>
After completion, create `.planning/phases/11-firebase-modular-api/11-02-SUMMARY.md`
</output>
