---
phase: 18-content-visibility
plan: 01-FIX
type: fix
---

<objective>
Fix 4 UAT issues from plan 18-01.

Source: 18-01-ISSUES.md
Priority: 0 critical, 2 major, 2 minor
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md

**Issues being fixed:**
@.planning/phases/18-content-visibility/18-01-ISSUES.md

**Original plan for reference:**
@.planning/phases/18-content-visibility/18-01-PLAN.md

**Key source files:**
@src/services/firebase/feedService.js
@src/services/firebase/photoService.js
@src/screens/FeedScreen.js
</context>

<tasks>

<task type="auto">
  <name>Fix UAT-004: Use triagedAt instead of capturedAt for visibility</name>
  <files>src/services/firebase/feedService.js</files>
  <action>
Change visibility filtering to use `triagedAt` timestamp instead of `capturedAt`:

1. In `getCutoffTimestamp` comment, clarify it's for visibility windows based on triage time

2. Update `getFeedPhotos`:
   - Change `where('capturedAt', '>=', cutoff)` to `where('triagedAt', '>=', cutoff)`
   - This ensures visibility window starts from when photo was triaged to journal

3. Update `subscribeFeedPhotos`:
   - Change `where('capturedAt', '>=', cutoff)` to `where('triagedAt', '>=', cutoff)`

4. Update `getFriendStoriesData` (inner photosQuery):
   - Change `where('capturedAt', '>=', cutoff)` to `where('triagedAt', '>=', cutoff)`

5. Update `getUserStoriesData`:
   - Change `where('capturedAt', '>=', cutoff)` to `where('triagedAt', '>=', cutoff)`

**Important**: Keep sorting by `capturedAt` for photo order (chronological display) - only change the visibility filter to use `triagedAt`.

**Rationale**: Users often wait days to triage photos, so using capturedAt causes photos to "expire" from feed/stories before anyone sees them. Using triagedAt starts the visibility window from when the user chose to share the photo.
</action>
<verify>
Run `grep -n "triagedAt.*cutoff\|where.*triagedAt" src/services/firebase/feedService.js` to confirm all four query functions now filter by triagedAt instead of capturedAt.
</verify>
<done>

- getFeedPhotos filters by `triagedAt >= cutoff` (1-day window)
- subscribeFeedPhotos filters by `triagedAt >= cutoff` (1-day window)
- getFriendStoriesData filters by `triagedAt >= cutoff` (7-day window)
- getUserStoriesData filters by `triagedAt >= cutoff` (7-day window)
- Sorting still uses capturedAt for chronological photo order
  </done>
  </task>

<task type="auto">
  <name>Fix UAT-002: Data migration for missing photoState field</name>
  <files>src/services/firebase/photoService.js</files>
  <action>
Add a data migration function to fix older photos that have `photoState: null`:

1. Create `migratePhotoStateField()` function in photoService.js:
   - Query all photos where `status == 'triaged'`
   - Filter client-side for photos where `photoState` is null or undefined
   - For each matching photo:
     - Check if `triageAction` field exists to determine intent (optional)
     - Set `photoState: 'journal'` as the default (matches existing behavior)
     - Set `triagedAt` to the photo's `updatedAt` or `capturedAt` if missing
   - Use batch writes for efficiency (max 500 per batch)
   - Return count of migrated photos

2. Export the function so it can be called from settings or admin screen

**Note**: This is a one-time migration. After running, all triaged photos will have proper `photoState` and `triagedAt` fields.

**Safety**: This only updates photos where photoState is null - it won't overwrite existing photoState values.
</action>
<verify>
Read the file and confirm `migratePhotoStateField` function exists and:

- Queries triaged photos
- Filters for null/undefined photoState
- Sets photoState to 'journal' and ensures triagedAt is set
- Uses batch writes
  </verify>
  <done>
- `migratePhotoStateField()` function exists in photoService.js
- Function handles null/undefined photoState on triaged photos
- Sets photoState to 'journal' and ensures triagedAt timestamp
- Uses Firestore batch writes for efficiency
- Exported for use from settings/admin
  </done>
  </task>

<task type="auto">
  <name>Fix UAT-003: Pull-to-refresh should reload stories</name>
  <files>src/screens/FeedScreen.js</files>
  <action>
Update the `handleRefresh` function to also reload own stories:

Current implementation (line 253):

```javascript
await Promise.all([refreshFeed(), loadFriendStories()]);
```

Change to:

```javascript
await Promise.all([refreshFeed(), loadFriendStories(), loadMyStories()]);
```

This ensures pull-to-refresh reloads:

1. Feed photos
2. Friend stories (already working)
3. Own stories (MeStoryCard - currently missing)
   </action>
   <verify>
   Run `grep -n "handleRefresh\|loadMyStories\|loadFriendStories" src/screens/FeedScreen.js | grep -A2 "handleRefresh"` and confirm all three functions are called in parallel.
   </verify>
   <done>

- handleRefresh calls refreshFeed(), loadFriendStories(), AND loadMyStories()
- All three data sources refresh on pull-to-refresh
- Stories bar updates properly on refresh
  </done>
  </task>

<task type="auto">
  <name>Fix UAT-005: Show random friend photos when feed is empty</name>
  <files>src/services/firebase/feedService.js, src/screens/FeedScreen.js</files>
  <action>
Add fallback to show random older friend photos when no recent posts exist:

1. **In feedService.js** - Create `getRandomFriendPhotos()` function:
   - Takes friendUserIds and limitCount parameters
   - Queries photos where `photoState == 'journal'` and `userId in friendUserIds`
   - NO time filter (gets all historical photos)
   - Shuffles results randomly
   - Returns limited count of random photos
   - Used as fallback when recent feed is empty

2. **In FeedScreen.js** - Update feed loading logic:
   - In `loadFeedPhotos()` or where feed data is processed:
   - After loading recent photos, if `photos.length === 0` AND `friendUserIds.length > 0`:
     - Call `getRandomFriendPhotos(friendUserIds, 10)` as fallback
     - Display these with a subtle indicator that they're "from the archives" (optional)
   - Keep existing empty states for users with no friends

**User experience**: Feed never appears empty if user has friends with photos - always shows something interesting, even if not recent.
</action>
<verify>

1. `grep -n "getRandomFriendPhotos" src/services/firebase/feedService.js` shows function exists
2. `grep -n "getRandomFriendPhotos" src/screens/FeedScreen.js` shows it's used as fallback
   </verify>
   <done>

- getRandomFriendPhotos() function exists in feedService.js
- FeedScreen falls back to random photos when recent feed is empty
- Feed shows historical friend photos instead of empty state (when friends have photos)
- Empty state still shows for users with no friends
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All four issues fixed (UAT-002, UAT-003, UAT-004, UAT-005)
- [ ] Visibility filtering uses triagedAt instead of capturedAt
- [ ] Migration function exists for older photos missing photoState
- [ ] Pull-to-refresh reloads friend stories AND own stories
- [ ] Empty feed shows random friend photos as fallback
- [ ] App builds without errors
</verification>

<success_criteria>

- All UAT issues from 18-01-ISSUES.md addressed
- Tests pass
- Ready for re-verification with /gsd:verify-work
  </success_criteria>

<output>
After completion, create `.planning/phases/18-content-visibility/18-01-FIX-SUMMARY.md`
</output>
