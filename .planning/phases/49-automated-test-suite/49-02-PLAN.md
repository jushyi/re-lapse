---
phase: 49-automated-test-suite
plan: 02
type: execute
---

<objective>
Write unit tests for social-layer Firebase services: commentService, mentionService, blockService, and reportService.

Purpose: Cover the social interaction services that handle comments, @mentions, user blocking, and reporting — critical paths where silent breakage would impact user safety and engagement.
Output: Passing test suites for all 4 social services with mocked Firebase calls.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/49-automated-test-suite/49-RESEARCH.md
@.planning/codebase/TESTING.md
@.planning/codebase/CONVENTIONS.md

@**tests**/setup/jest.setup.js
@**tests**/setup/testFactories.js
@**tests**/services/friendshipService.test.js (reference for existing patterns)
@src/services/firebase/commentService.js
@src/services/firebase/mentionService.js
@src/services/firebase/blockService.js
@src/services/firebase/reportService.js

**Established patterns:** Import service after mocks, beforeEach with jest.clearAllMocks(), mockResolvedValue/mockRejectedValue for async, test success + error cases
**Constraining decisions:**

- mentionService.getMutualFriendsForTagging calls a Cloud Function via httpsCallable — mock @react-native-firebase/functions (added in 49-01)
- commentService uses subcollections (photos/{photoId}/comments) — mock Firestore collection/doc/add/get/delete chain
- Services return { success, data/error } pattern — test both success and error paths
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Write commentService unit tests</name>
  <files>__tests__/services/commentService.test.js</files>
  <action>
Follow existing test patterns from friendshipService.test.js. Test all 8 exported functions:

1. **addComment** — success case (creates comment doc with correct fields including parentId and mentionedCommentId), error case (Firestore write fails)
2. **deleteComment** — success case (deletes correct doc), error case (doc doesn't exist), auth case (requestingUserId doesn't match comment owner)
3. **getComments** — returns array of comments with pagination (limitCount), empty collection returns [], error handling
4. **subscribeToComments** — calls onSnapshot with callback, returns unsubscribe function, handles snapshot errors
5. **getPreviewComments** — returns limited preview comments for photo card display, filters correctly by photoOwnerId
6. **hasUserLikedComment** — returns true/false based on subcollection doc existence
7. **toggleCommentLike** — adds like doc when not liked, removes when already liked
8. **getUserLikesForComments** — batch checks multiple comment IDs, returns Set of liked comment IDs

Mock Firestore subcollection pattern: `collection(db, 'photos', photoId, 'comments')`. Use createTestComment factory from testFactories.js for test data. Include at least 2 tests per function (success + error/edge case).
</action>
<verify>npm test -- --testPathPattern="commentService" passes all tests</verify>
<done>commentService.test.js passes with tests covering all 8 exported functions, both success and error paths</done>
</task>

<task type="auto">
  <name>Task 2: Write mentionService unit tests</name>
  <files>__tests__/services/mentionService.test.js</files>
  <action>
mentionService has 1 exported function that calls a Cloud Function:

1. **getMutualFriendsForTagging(photoOwnerId)** — calls httpsCallable('getMutualFriendsForComments'), returns list of mutual friends. Test:
   - Success: Cloud Function returns array of user objects → service returns them
   - Empty result: No mutual friends → returns empty array
   - Error: Cloud Function throws → service handles error gracefully (returns { success: false } or empty array — read the actual error handling pattern in the source)
   - Invalid input: null/undefined photoOwnerId

Mock pattern: The @react-native-firebase/functions mock from jest.setup.js provides `httpsCallable` which returns a callable function. Set up the mock chain:

```
const mockCallable = jest.fn();
functions().httpsCallable.mockReturnValue(mockCallable);
mockCallable.mockResolvedValue({ data: [...friends] });
```

  </action>
  <verify>npm test -- --testPathPattern="mentionService" passes all tests</verify>
  <done>mentionService.test.js passes with success, empty, error, and invalid input cases</done>
</task>

<task type="auto">
  <name>Task 3: Write blockService and reportService unit tests</name>
  <files>__tests__/services/blockService.test.js, __tests__/services/reportService.test.js</files>
  <action>
**blockService (6 functions):**
1. **blockUser** — creates block document, test success + already blocked + error
2. **unblockUser** — removes block document, test success + not blocked + error
3. **isBlocked** — returns boolean, test blocked/not-blocked/error
4. **getBlockedByUserIds** — returns array of userIds who blocked this user
5. **getBlockedUserIds** — returns array of userIds this user blocked
6. **getBlockedUsersWithProfiles** — returns user profiles for blocked users (combines block docs + user profile fetches)

**reportService (1 function + 1 constant):**

1. **REPORT_REASONS** — verify constant array contains expected values: ['spam', 'harassment', 'inappropriate', 'impersonation', 'other']
2. **submitReport** — creates report document with reporterId, reportedUserId, reason, details, profileSnapshot. Test:
   - Success: valid report created
   - Error: Firestore write fails
   - Verify profileSnapshot is included correctly

Both services use the standard Firestore mock pattern. Use createTestBlock factory for blockService test data. Keep tests focused on behavior — test what gets written to Firestore, not internal implementation details.
</action>
<verify>npm test -- --testPathPattern="blockService|reportService" passes all tests; npm test passes full suite</verify>
<done>blockService.test.js and reportService.test.js pass; all 4 social service test files green; full suite green</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test` passes all tests (existing + new social service tests)
- [ ] commentService.test.js covers all 8 functions
- [ ] mentionService.test.js covers getMutualFriendsForTagging
- [ ] blockService.test.js covers all 6 functions
- [ ] reportService.test.js covers submitReport + REPORT_REASONS
- [ ] Each test file follows established patterns (beforeEach, clearAllMocks, Arrange/Act/Assert)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Social service tests cover both success and error paths
- Tests use testFactories for consistent test data
  </success_criteria>

<output>
After completion, create `.planning/phases/49-automated-test-suite/49-02-SUMMARY.md`
</output>
