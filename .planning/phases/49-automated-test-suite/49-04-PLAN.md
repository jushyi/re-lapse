---
phase: 49-automated-test-suite
plan: 04
type: execute
---

<objective>
Write unit tests for complex custom hooks using @testing-library/react-native renderHook.

Purpose: Test the hooks that contain significant business logic — mention suggestions filtering, comment state management, feed photo pagination, and darkroom reveal state. These hooks are the bridge between services and UI, where logic bugs silently degrade user experience.
Output: Passing hook test suites for useMentionSuggestions, useComments, useFeedPhotos, and useDarkroom.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/49-automated-test-suite/49-RESEARCH.md
@.planning/codebase/TESTING.md

@**tests**/setup/jest.setup.js
@**tests**/setup/testFactories.js
@src/hooks/useMentionSuggestions.js
@src/hooks/useComments.js
@src/hooks/useFeedPhotos.js
@src/hooks/useDarkroom.js

**Tech stack available:** @testing-library/react-native v13 (installed in 49-01)
**Established patterns:** RNTL renderHook is async in v13 — always await renderHook()
**Constraining decisions:**

- RNTL v13 APIs are async — await render(), await renderHook(), await fireEvent()
- React Compiler memoization runs during Jest — don't test re-render counts
- Hooks depend on Firebase services — mock service modules, not Firebase directly
- useFeedPhotos uses AuthContext — needs wrapper provider for renderHook
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Write useMentionSuggestions and useComments hook tests</name>
  <files>__tests__/hooks/useMentionSuggestions.test.js, __tests__/hooks/useComments.test.js</files>
  <action>
**useMentionSuggestions(photoOwnerId, currentUserId):**
Mock the mentionService.getMutualFriendsForTagging call. Test:
1. Loads mutual friends on mount — returns suggestions array
2. Returns empty array when no mutual friends
3. Handles loading state correctly (isLoading starts true, becomes false)
4. Handles error from service gracefully
5. Does not fetch if photoOwnerId is null/undefined

Use `await renderHook(() => useMentionSuggestions('owner-123', 'current-456'))`. Mock at the service module level: `jest.mock('../../src/services/firebase/mentionService')`.

**useComments(photoId, currentUserId, photoOwnerId):**
Mock commentService functions. Test:

1. Subscribes to comments on mount via subscribeToComments
2. Returns comments array from subscription
3. addComment calls commentService.addComment with correct params
4. deleteComment calls commentService.deleteComment
5. toggleLike calls commentService.toggleCommentLike
6. Unsubscribes on unmount (verify unsubscribe function called)
7. Handles empty photoId (no subscription)

For subscription testing: mock subscribeToComments to immediately invoke the callback with test data, and return a mock unsubscribe function. Use `result.current.unmount` or renderHook cleanup to verify unsubscribe.

**Critical RNTL v13 pattern:**

```javascript
import { renderHook, act, waitFor } from '@testing-library/react-native';

test('loads suggestions', async () => {
  getMutualFriendsForTagging.mockResolvedValue({ success: true, data: mockFriends });
  const { result } = await renderHook(() => useMentionSuggestions('owner', 'current'));
  await waitFor(() => expect(result.current.suggestions).toHaveLength(2));
});
```

  </action>
  <verify>npm test -- --testPathPattern="hooks" passes all hook tests</verify>
  <done>useMentionSuggestions.test.js and useComments.test.js pass with all specified test cases</done>
</task>

<task type="auto">
  <name>Task 2: Write useFeedPhotos and useDarkroom hook tests</name>
  <files>__tests__/hooks/useFeedPhotos.test.js, __tests__/hooks/useDarkroom.test.js</files>
  <action>
**useFeedPhotos(enableRealtime, hotOnly):**
Mock feedService functions. This hook likely uses AuthContext for the current user — create a wrapper:
```javascript
const wrapper = ({ children }) => (
  <AuthContext.Provider value={{ user: { uid: 'test-user' } }}>
    {children}
  </AuthContext.Provider>
);
```

Test:

1. Fetches feed photos on mount — returns photos array
2. Handles enableRealtime=true (subscribes) vs false (one-time fetch)
3. Handles hotOnly filter
4. Returns loading/error states
5. Handles empty feed (no friends, no photos)
6. Cleans up subscription on unmount if realtime

If AuthContext import path is different, read the source first and adjust. Mock at service module level.

**useDarkroom():**
Mock darkroomService functions. Test:

1. Loads darkroom state on mount
2. Returns developing photos count
3. Returns reveal countdown/timer state
4. Handles no active darkroom (no developing photos)
5. Handles reveal ready state (countdown complete)
6. Refreshes darkroom state when called

Both hooks: use `await renderHook(...)`, `await waitFor(...)` for async state updates. Do NOT test re-render counts due to React Compiler memoization. Focus on what the hook returns and what side effects it triggers.
</action>
<verify>npm test -- --testPathPattern="hooks" passes all hook tests; npm test passes full suite</verify>
<done>useFeedPhotos.test.js and useDarkroom.test.js pass; all 4 hook test files green; full suite green</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test` passes all tests (existing + new hook tests)
- [ ] useMentionSuggestions.test.js covers load, empty, error, null-guard cases
- [ ] useComments.test.js covers subscribe, add, delete, like, unsubscribe
- [ ] useFeedPhotos.test.js covers fetch, realtime, filter, cleanup
- [ ] useDarkroom.test.js covers load, countdown, reveal-ready, refresh
- [ ] All hook tests use async RNTL v13 patterns (await renderHook, waitFor)
- [ ] No React Compiler re-render assertions
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- Hook tests verify behavior, not implementation
- All async patterns use proper await/waitFor
  </success_criteria>

<output>
After completion, create `.planning/phases/49-automated-test-suite/49-04-SUMMARY.md`
</output>
