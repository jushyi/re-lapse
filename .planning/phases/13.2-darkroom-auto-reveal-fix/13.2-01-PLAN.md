---
phase: 13.2-darkroom-auto-reveal-fix
plan: 01
type: execute
---

<objective>
Fix darkroom auto-reveal bug: photos stuck in 'developing' state when nextRevealAt passes without user opening DarkroomScreen.

Purpose: Ensure photos are revealed when their time comes, regardless of when user opens darkroom or captures new photos.
Output: Working darkroom reveal system where ensureDarkroomInitialized reveals overdue photos before resetting timing, and app proactively checks for reveals on foreground.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13.1-darkroom-reveal-timing-fix/13.1-01-SUMMARY.md
@src/services/firebase/darkroomService.js
@src/services/firebase/photoService.js
@src/screens/DarkroomScreen.js

**Bug Analysis:**

The current implementation has two related issues:

1. **ensureDarkroomInitialized() resets stale timing without revealing:**
   - Called on photo capture (from photoService.createPhoto)
   - When nextRevealAt is in the past, it calculates new future time and updates Firestore
   - It does NOT reveal the developing photos first
   - Result: Photos stay in 'developing' forever because the reveal window was silently extended

2. **No proactive reveal mechanism:**
   - Reveal logic only runs in DarkroomScreen.useFocusEffect
   - If user never opens darkroom, photos never reveal
   - If user captures a new photo while old photos are overdue, old photos get their window extended (issue #1)

**Current Code Flow (broken):**

```
User captures photo
  → photoService.createPhoto()
    → ensureDarkroomInitialized(userId)
      → If nextRevealAt is stale:
        → updateDoc(darkroomRef, { nextRevealAt: NEW_TIME })  // PROBLEM: photos not revealed
        → Return success
```

**Fixed Code Flow (target):**

```
User captures photo
  → photoService.createPhoto()
    → ensureDarkroomInitialized(userId)
      → If nextRevealAt is stale:
        → revealPhotos(userId)  // NEW: reveal overdue photos first
        → updateDoc(darkroomRef, { nextRevealAt: NEW_TIME, lastRevealedAt: now })
        → Return success
```

**Tech available from prior phases:**
- revealPhotos() function in photoService.js (used by DarkroomScreen)
- isDarkroomReadyToReveal() function in darkroomService.js
- useFocusEffect pattern for screen-level checks
- AppState listener pattern (from React Native)

**Constraining decisions:**
- Phase 13.1: Changed interval to 0-15 minutes
- Phase 13.1: Added ensureDarkroomInitialized() on photo capture
- Architecture: Client-side only (no Cloud Functions for auto-reveal)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix ensureDarkroomInitialized to reveal photos before resetting stale timing</name>
  <files>src/services/firebase/darkroomService.js</files>
  <action>
Import revealPhotos from photoService at the top of darkroomService.js.

Modify ensureDarkroomInitialized() to call revealPhotos() BEFORE updating a stale nextRevealAt:

1. In the stale check block (lines 151-164), before calling updateDoc:
   - Log that we're revealing overdue photos first
   - Call: await revealPhotos(userId) from photoService
   - Log the reveal result
   - Only then update nextRevealAt with the new time
   - Also set lastRevealedAt: serverTimestamp() since we just revealed

2. Add serverTimestamp import if not already present.

3. The updated flow should be:
   ```javascript
   if (!nextRevealAt || nextRevealAt.seconds < now.seconds) {
     // Reveal overdue photos first!
     logger.info('ensureDarkroomInitialized: Revealing overdue photos before resetting', { userId });
     const revealResult = await revealPhotos(userId);
     logger.info('ensureDarkroomInitialized: Reveal result', { userId, revealResult });

     // Now schedule next reveal
     const newNextRevealAt = calculateNextRevealTime();
     await updateDoc(darkroomRef, {
       nextRevealAt: newNextRevealAt,
       lastRevealedAt: serverTimestamp(),
     });
     return { success: true, refreshed: true, revealed: revealResult.count };
   }
   ```

IMPORTANT: Be careful about circular imports. If circular import occurs, move revealPhotos to darkroomService or create a shared reveal utility. However, since darkroomService doesn't import from photoService currently, and photoService already imports from darkroomService (for ensureDarkroomInitialized), adding import of revealPhotos to darkroomService would create a circular dependency.

ALTERNATIVE (if circular import): Move the reveal logic inline into darkroomService:
- Import collection, query, where, getDocs, updateDoc from firestore
- Query photos where userId==userId AND status=='developing'
- Update each to status: 'revealed', revealedAt: serverTimestamp()

This duplicates some logic but avoids circular dependency.
  </action>
  <verify>
1. Run Metro bundler (npx expo start) - should start without import errors
2. Take a photo while having a stale nextRevealAt (can set manually in Firestore console for testing)
3. Check logs for "Revealing overdue photos before resetting" message
4. Check Firestore: developing photos should now be 'revealed' AND nextRevealAt should be in the future
  </verify>
  <done>
- ensureDarkroomInitialized reveals overdue photos before resetting stale nextRevealAt
- No circular import errors
- Logs show reveal happening during photo capture when darkroom was stale
  </done>
</task>

<task type="auto">
  <name>Task 2: Add app-level reveal check on foreground</name>
  <files>App.js</files>
  <action>
Add an AppState listener that checks for pending reveals when app comes to foreground.

1. Import AppState from 'react-native' at top of App.js
2. Import isDarkroomReadyToReveal from darkroomService
3. Import revealPhotos from photoService (or the combined function if Task 1 created one)
4. Import scheduleNextReveal from darkroomService

5. Inside the main App component, after existing notification initialization:
   - Add a useEffect for AppState listener
   - When app state changes to 'active' (foreground):
     - Get the current user from auth (check if user exists first)
     - If user exists, call isDarkroomReadyToReveal(user.uid)
     - If ready, call revealPhotos() then scheduleNextReveal()
     - Log the action

Example implementation:
```javascript
useEffect(() => {
  const subscription = AppState.addEventListener('change', async (nextAppState) => {
    if (nextAppState === 'active') {
      // Check for pending reveals when app comes to foreground
      const currentUser = auth().currentUser;
      if (currentUser) {
        logger.debug('App: Checking for pending reveals on foreground', { userId: currentUser.uid });
        const isReady = await isDarkroomReadyToReveal(currentUser.uid);
        if (isReady) {
          logger.info('App: Revealing photos on foreground', { userId: currentUser.uid });
          await revealPhotos(currentUser.uid);
          await scheduleNextReveal(currentUser.uid);
        }
      }
    }
  });

  return () => subscription.remove();
}, []);
```

NOTE: Import auth from '@react-native-firebase/auth' to get currentUser.
  </action>
  <verify>
1. Put app in background, wait for nextRevealAt to pass
2. Bring app to foreground
3. Check logs for "Checking for pending reveals on foreground" and "Revealing photos on foreground"
4. Open DarkroomScreen - photos should already be revealed
  </verify>
  <done>
- App checks for pending reveals when coming to foreground
- Photos reveal automatically even without opening DarkroomScreen
- No duplicate reveals (DarkroomScreen check still works but finds photos already revealed)
  </done>
</task>

</tasks>

<verification>
Before declaring phase complete:
- [ ] Metro bundler starts without errors (no circular imports)
- [ ] Photo capture with stale darkroom: logs show reveal before reset
- [ ] App foreground with stale darkroom: logs show foreground reveal check
- [ ] Developing photos become 'revealed' when nextRevealAt passes (via either mechanism)
- [ ] New photos captured after reveal get their own future nextRevealAt
- [ ] DarkroomScreen still shows revealed photos correctly
</verification>

<success_criteria>

- Photos no longer stuck in 'developing' state indefinitely
- ensureDarkroomInitialized reveals overdue photos before resetting timing
- App proactively reveals on foreground
- No circular import errors
- Existing DarkroomScreen functionality preserved
</success_criteria>

<output>
After completion, create `.planning/phases/13.2-darkroom-auto-reveal-fix/13.2-01-SUMMARY.md`:

# Phase 13.2 Plan 01: Darkroom Auto-Reveal Fix Summary

**[Substantive one-liner describing what shipped]**

## Performance

- **Duration:** X min
- **Tasks:** 2
- **Files modified:** 2

## Accomplishments

- [Key outcome 1]
- [Key outcome 2]

## Task Commits

Each task was committed atomically:

1. **Task 1:** [commit hash] (feat/fix)
2. **Task 2:** [commit hash] (feat/fix)

## Files Created/Modified

- `src/services/firebase/darkroomService.js` - Description
- `App.js` - Description

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Phase 13.2 complete, ready for Phase 14: Remote Notification Testing & Polish.
</output>
