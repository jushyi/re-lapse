# Phase 15.3: ISS-001 - Add True 0.5x Ultra-Wide Zoom - Research

**Researched:** 2026-01-21
**Domain:** expo-camera multi-lens API for iOS ultra-wide camera access
**Confidence:** HIGH (iOS), LOW (Android)

<research_summary>
## Summary

Researched how to implement true 0.5x ultra-wide zoom in React Native/Expo by switching to the physical ultra-wide lens rather than using digital zoom. The good news: **expo-camera already supports this on iOS** via the `selectedLens` prop and `getAvailableLensesAsync()` method, added in April 2025 (PR #36233).

Key finding: This is an **iOS-only feature** in expo-camera. The API directly exposes Apple's AVFoundation device types including `builtInUltraWideCamera`. For Android, there is currently no equivalent lens selection API in expo-camera - it would require react-native-vision-camera or native code.

**Primary recommendation:** Use expo-camera's existing `selectedLens` prop on iOS with device capability detection. For Android, either accept the limitation (no 0.5x) or consider react-native-vision-camera as a future enhancement (requires dev build).
</research_summary>

<standard_stack>
## Standard Stack

### Core (Already in Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| expo-camera | 17.0.10 | Camera access with lens selection | Already in project, has iOS lens API |
| expo-device | 8.0.10 | Device info for capability checks | Already in project |

### No Additional Libraries Required
The existing expo-camera setup supports lens selection on iOS without any new dependencies. The feature is built-in.

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| expo-camera | react-native-vision-camera | Better multi-lens support on both platforms, but requires dev build (no Expo Go), more complex setup, new dependency |
| Lens switching | Digital zoom only | Simpler but lower quality, not true 0.5x |

**Installation:**
```bash
# No new packages needed - expo-camera already supports this
# Current project already has expo-camera@~17.0.10
```
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Recommended Implementation Pattern

```
Current CameraScreen.js Structure:
├── ZOOM_LEVELS constant (defines zoom options)
├── CameraView component (renders camera)
├── zoom prop (currently uses cameraZoom 0-1 range)
└── handleZoomChange (switches zoom level)

New Pattern:
├── ZOOM_LEVELS constant → Add 0.5x level with lens flag
├── useState for selectedLens → Track active lens
├── getAvailableLensesAsync() → Detect device capabilities
├── CameraView with selectedLens prop → Switch physical lens
└── Conditional zoom bar → Only show 0.5x if device supports it
```

### Pattern 1: Device Capability Detection
**What:** Query available lenses on camera mount and store in state
**When to use:** When camera component loads or when front/back camera toggles
**Example:**
```javascript
// From expo-camera docs + PR #36233
const cameraRef = useRef(null);
const [availableLenses, setAvailableLenses] = useState([]);
const [selectedLens, setSelectedLens] = useState(null);

// Called when camera is ready or facing changes
const loadAvailableLenses = async () => {
  if (cameraRef.current && Platform.OS === 'ios') {
    const lenses = await cameraRef.current.getAvailableLensesAsync();
    setAvailableLenses(lenses);
    // Check if ultra-wide is available
    const hasUltraWide = lenses.some(l =>
      l.includes('UltraWide') || l.includes('ultrawide')
    );
    console.log('Available lenses:', lenses);
  }
};

// Also listen to callback
<CameraView
  ref={cameraRef}
  onAvailableLensesChanged={(event) => {
    setAvailableLenses(event.lenses);
  }}
  selectedLens={selectedLens}
/>
```

### Pattern 2: Conditional Zoom Levels
**What:** Only show 0.5x option if device has ultra-wide lens
**When to use:** When rendering zoom bar UI
**Example:**
```javascript
// Dynamically build zoom levels based on device capability
const getZoomLevels = (hasUltraWide) => {
  const levels = [
    { label: '1', value: 1, lens: 'builtInWideAngleCamera', cameraZoom: 0 },
    { label: '2', value: 2, lens: 'builtInWideAngleCamera', cameraZoom: 0.17 },
    { label: '3', value: 3, lens: 'builtInWideAngleCamera', cameraZoom: 0.33 },
  ];

  if (hasUltraWide) {
    // Insert 0.5x at beginning
    levels.unshift({
      label: '0.5',
      value: 0.5,
      lens: 'builtInUltraWideCamera',
      cameraZoom: 0, // Ultra-wide uses native lens, not digital zoom
    });
  }

  return levels;
};
```

### Pattern 3: Platform-Specific Implementation
**What:** iOS uses lens switching, Android falls back to digital zoom or no 0.5x
**When to use:** Cross-platform apps where feature parity isn't required
**Example:**
```javascript
import { Platform } from 'react-native';

const handleZoomChange = (zoomLevel) => {
  if (Platform.OS === 'ios' && zoomLevel.lens) {
    setSelectedLens(zoomLevel.lens);
  }
  setZoom(zoomLevel);
};

<CameraView
  ref={cameraRef}
  facing={facing}
  flash={flash}
  zoom={zoom.cameraZoom}
  // iOS-only lens selection
  {...(Platform.OS === 'ios' && selectedLens && { selectedLens })}
/>
```

### Anti-Patterns to Avoid
- **Using digital zoom for 0.5x:** Negative zoom values don't work in expo-camera; you must switch lenses for true ultra-wide
- **Assuming all devices have ultra-wide:** iPhone 11+ have ultra-wide, but older devices and many Android phones don't
- **Not handling lens unavailability:** Always check `getAvailableLensesAsync()` result before showing 0.5x option
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Lens enumeration | Manual device checks by model name | `getAvailableLensesAsync()` | API returns actual available lenses, handles device variations |
| Ultra-wide detection | Hardcoded list of devices with ultra-wide | Check for `builtInUltraWideCamera` in lens array | Future-proof, accurate |
| Lens switching | Custom native module | expo-camera `selectedLens` prop | Already implemented, tested, maintained |
| Cross-platform abstraction | Complex Platform.select logic | Simple `Platform.OS === 'ios'` check | Android support doesn't exist in expo-camera, keep it simple |

**Key insight:** expo-camera already solved the hard problem of exposing iOS AVFoundation lens types through JavaScript. The API is straightforward - just pass the lens name string. Don't over-engineer detection logic.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Expecting Android Support
**What goes wrong:** Implementing lens selection assuming it works on both platforms
**Why it happens:** Documentation mentions `selectedLens` but doesn't prominently state iOS-only
**How to avoid:** Check `Platform.OS === 'ios'` before using lens APIs; gracefully hide 0.5x on Android
**Warning signs:** Undefined behavior on Android, no lenses returned from `getAvailableLensesAsync()`

### Pitfall 2: Not Handling Front Camera
**What goes wrong:** Showing 0.5x option when front camera is active
**Why it happens:** Ultra-wide is typically back-camera only
**How to avoid:** Re-check available lenses when `facing` changes; ultra-wide usually only on back
**Warning signs:** Lens not found error, camera freezes on front camera

### Pitfall 3: Wrong Lens Name String
**What goes wrong:** Passing incorrect lens identifier
**Why it happens:** Apple's AVFoundation uses specific device type strings that may vary
**How to avoid:** Use the exact string returned by `getAvailableLensesAsync()`, don't hardcode
**Warning signs:** "Invalid lens type" error, lens doesn't change

### Pitfall 4: UI Shows 0.5x Before Capability Check
**What goes wrong:** Flash of 0.5x button on devices without ultra-wide
**Why it happens:** Rendering zoom bar before async lens check completes
**How to avoid:** Initialize zoom levels without 0.5x, add it after capability check
**Warning signs:** Flashing UI, 0.5x visible then disappears

### Pitfall 5: Zoom State Conflict
**What goes wrong:** Setting both selectedLens AND high cameraZoom value
**Why it happens:** Misunderstanding that ultra-wide is separate from zoom range
**How to avoid:** When switching to ultra-wide, set cameraZoom to 0; ultra-wide IS the 0.5x, not zoom on wide
**Warning signs:** Unexpected magnification, image doesn't look ultra-wide
</common_pitfalls>

<code_examples>
## Code Examples

Verified patterns from official sources:

### Basic Lens Selection (iOS)
```javascript
// Source: Expo docs + PR #36233
import { CameraView, useCameraPermissions } from 'expo-camera';
import { Platform } from 'react-native';

function CameraWithLensSelection() {
  const cameraRef = useRef(null);
  const [selectedLens, setSelectedLens] = useState(null);
  const [availableLenses, setAvailableLenses] = useState([]);

  const handleAvailableLensesChanged = (event) => {
    if (Platform.OS === 'ios') {
      setAvailableLenses(event.lenses);
      console.log('Available lenses:', event.lenses);
    }
  };

  return (
    <CameraView
      ref={cameraRef}
      selectedLens={selectedLens}
      onAvailableLensesChanged={handleAvailableLensesChanged}
    />
  );
}
```

### Checking for Ultra-Wide Support
```javascript
// Source: Pattern derived from Apple AVFoundation docs
const hasUltraWide = availableLenses.some(lens =>
  lens.toLowerCase().includes('ultrawide') ||
  lens.includes('UltraWide')
);

// Expected lens strings from iOS (from PR #36233 discussion):
// - "AVCaptureDeviceTypeBuiltInUltraWideCamera"
// - "AVCaptureDeviceTypeBuiltInWideAngleCamera"
// - "AVCaptureDeviceTypeBuiltInTelephotoCamera"
// - "AVCaptureDeviceTypeBuiltInDualCamera"
// - "AVCaptureDeviceTypeBuiltInTripleCamera"
```

### Integration with Existing Zoom Bar
```javascript
// Source: Derived pattern for Lapse Clone
const ZOOM_LEVELS_BASE = [
  { label: '1', value: 1, lens: null, cameraZoom: 0 },
  { label: '2', value: 2, lens: null, cameraZoom: 0.17 },
  { label: '3', value: 3, lens: null, cameraZoom: 0.33 },
];

const ULTRA_WIDE_LEVEL = {
  label: '0.5',
  value: 0.5,
  lens: 'AVCaptureDeviceTypeBuiltInUltraWideCamera',
  cameraZoom: 0,
};

// Build zoom levels dynamically
const zoomLevels = useMemo(() => {
  if (Platform.OS === 'ios' && hasUltraWide && facing === 'back') {
    return [ULTRA_WIDE_LEVEL, ...ZOOM_LEVELS_BASE];
  }
  return ZOOM_LEVELS_BASE;
}, [hasUltraWide, facing]);
```
</code_examples>

<sota_updates>
## State of the Art (2025-2026)

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| No lens selection in expo-camera | `selectedLens` prop + `getAvailableLensesAsync()` | April 2025 (PR #36233) | iOS can now switch physical lenses |
| Only digital zoom (0-1 range) | Physical lens switching on iOS | April 2025 | True 0.5x ultra-wide without quality loss |
| react-native-vision-camera required for multi-lens | expo-camera supports iOS lens selection | April 2025 | Simpler for iOS-only or iOS-first apps |

**New tools/patterns to consider:**
- **expo-camera lens selection:** Native in expo-camera, no additional library needed for iOS
- **Device capability callbacks:** `onAvailableLensesChanged` provides real-time lens info

**Deprecated/outdated:**
- **Negative zoom values for ultra-wide:** This never worked; must use lens switching
- **Hardcoding device support by model name:** Use API detection instead
</sota_updates>

<open_questions>
## Open Questions

Things that couldn't be fully resolved:

1. **Exact lens string format**
   - What we know: PR discussion mentions `AVCaptureDeviceTypeBuiltInUltraWideCamera`
   - What's unclear: Exact string casing/format returned by `getAvailableLensesAsync()` in production
   - Recommendation: Log actual values on first run, match dynamically rather than hardcoding

2. **Android future support**
   - What we know: Currently iOS-only in expo-camera; react-native-vision-camera supports Android
   - What's unclear: If/when expo-camera will add Android lens selection
   - Recommendation: Design UI to gracefully hide 0.5x on Android; consider vision-camera for Phase 2

3. **Lens transition smoothness**
   - What we know: iOS handles physical lens switches natively
   - What's unclear: Whether there's visual flicker during lens transition
   - Recommendation: Test on device; may need brief loading indicator during switch
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- [Expo Camera Documentation](https://docs.expo.dev/versions/latest/sdk/camera/) - selectedLens, getAvailableLensesAsync API
- [PR #36233: iOS Camera Lens Selection](https://github.com/expo/expo/pull/36233) - Implementation details, available lens types
- [Apple builtInUltraWideCamera Docs](https://developer.apple.com/documentation/avfoundation/avcapturedevice/devicetype/3377622-builtinultrawidecamera) - iOS 13+ device type

### Secondary (MEDIUM confidence)
- [React Native Vision Camera Devices Guide](https://react-native-vision-camera.com/docs/guides/devices) - Alternative approach verified against docs
- [React Native Vision Camera Zooming Guide](https://react-native-vision-camera.com/docs/guides/zooming) - Zoom behavior patterns

### Tertiary (LOW confidence - needs validation)
- Community examples suggest lens strings like "AVCaptureDeviceTypeBuiltInUltraWideCamera" - needs device testing
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: expo-camera lens selection API
- Ecosystem: React Native camera libraries comparison
- Patterns: iOS AVFoundation device types, capability detection
- Pitfalls: Platform differences, lens availability, UI timing

**Confidence breakdown:**
- Standard stack: HIGH - expo-camera already in project, API documented
- Architecture: HIGH - Clear patterns from official docs and PR
- Pitfalls: MEDIUM - Some based on inferred behavior, needs device testing
- Code examples: HIGH - Derived from official API documentation

**Research date:** 2026-01-21
**Valid until:** 2026-02-21 (30 days - expo-camera stable, iOS API stable)
</metadata>

---

*Phase: 15.3-ultra-wide-zoom*
*Research completed: 2026-01-21*
*Ready for planning: yes*
