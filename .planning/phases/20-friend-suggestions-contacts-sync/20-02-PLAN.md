---
phase: 20-friend-suggestions-contacts-sync
plan: 02
type: execute
---

<objective>
Create the onboarding contacts sync screen and integrate it into the app navigation flow.

Purpose: Provide a privacy-first contacts sync experience during onboarding that helps new users find and add friends from their contacts.
Output: ContactsSyncScreen.js with full UI, navigation integration in OnboardingStackNavigator, user document field for tracking sync completion.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-friend-suggestions-contacts-sync/20-CONTEXT.md
@.planning/phases/20-friend-suggestions-contacts-sync/20-RESEARCH.md
@.planning/phases/20-friend-suggestions-contacts-sync/20-01-SUMMARY.md

# Key source files:

@src/navigation/AppNavigator.js
@src/screens/SelectsScreen.js
@src/components/FriendCard.js
@src/services/firebase/contactSyncService.js
@src/constants/colors.js
@src/context/AuthContext.js

**Tech stack available:**

- contactSyncService.js (from Plan 01)
- FriendCard component for consistent suggestion display
- expo-contacts for permission handling

**Established patterns:**

- Screen structure: SafeAreaView, header with back button, content area
- Loading states with ActivityIndicator
- FriendCard for friend-related displays
- OnboardingStackNavigator for onboarding flow

**Constraining decisions from CONTEXT.md:**

- Privacy-first messaging: "contacts stay on device, we just match phone numbers"
- Onboarding timing: after profile setup (Selects), before hitting feed
- Bulk add: easy to add multiple friends at once
- Empty state: encourage sharing if no matches found
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create ContactsSyncScreen with privacy-first UI</name>
  <files>src/screens/ContactsSyncScreen.js, src/screens/index.js, src/styles/ContactsSyncScreen.styles.js</files>
  <action>
1. Create src/styles/ContactsSyncScreen.styles.js following existing style patterns:
```javascript
import { StyleSheet } from 'react-native';
import { colors } from '../constants/colors';

export const styles = StyleSheet.create({
container: {
flex: 1,
backgroundColor: colors.background.primary,
},
header: {
flexDirection: 'row',
alignItems: 'center',
paddingHorizontal: 16,
paddingVertical: 12,
},
backButton: {
marginRight: 12,
},
headerTitle: {
fontSize: 18,
fontWeight: '600',
color: colors.text.primary,
},
content: {
flex: 1,
paddingHorizontal: 20,
},
// Privacy messaging section
privacySection: {
alignItems: 'center',
paddingVertical: 32,
},
privacyIcon: {
marginBottom: 16,
},
privacyTitle: {
fontSize: 24,
fontWeight: '700',
color: colors.text.primary,
textAlign: 'center',
marginBottom: 12,
},
privacyText: {
fontSize: 15,
color: colors.text.secondary,
textAlign: 'center',
lineHeight: 22,
paddingHorizontal: 20,
},
// Sync button
syncButton: {
backgroundColor: colors.brand.purple,
paddingVertical: 16,
borderRadius: 12,
marginTop: 24,
},
syncButtonText: {
color: colors.text.primary,
fontSize: 16,
fontWeight: '600',
textAlign: 'center',
},
skipButton: {
paddingVertical: 16,
marginTop: 12,
},
skipButtonText: {
color: colors.text.secondary,
fontSize: 14,
textAlign: 'center',
},
// Results section
resultsHeader: {
paddingVertical: 16,
},
resultsTitle: {
fontSize: 20,
fontWeight: '700',
color: colors.text.primary,
marginBottom: 4,
},
resultsSubtitle: {
fontSize: 14,
color: colors.text.secondary,
},
listContent: {
paddingBottom: 100,
},
// Empty state
emptyContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
paddingHorizontal: 40,
},
emptyIcon: {
marginBottom: 16,
},
emptyTitle: {
fontSize: 20,
fontWeight: '700',
color: colors.text.primary,
textAlign: 'center',
marginBottom: 8,
},
emptyText: {
fontSize: 15,
color: colors.text.secondary,
textAlign: 'center',
lineHeight: 22,
},
// Loading state
loadingContainer: {
flex: 1,
justifyContent: 'center',
alignItems: 'center',
},
loadingText: {
marginTop: 16,
fontSize: 16,
color: colors.text.secondary,
},
// Continue button (fixed at bottom)
continueContainer: {
position: 'absolute',
bottom: 0,
left: 0,
right: 0,
paddingHorizontal: 20,
paddingVertical: 20,
paddingBottom: 40,
backgroundColor: colors.background.primary,
},
continueButton: {
backgroundColor: colors.brand.purple,
paddingVertical: 16,
borderRadius: 12,
},
continueButtonText: {
color: colors.text.primary,
fontSize: 16,
fontWeight: '600',
textAlign: 'center',
},
});

````

2. Create src/screens/ContactsSyncScreen.js:

```javascript
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  TouchableOpacity,
  FlatList,
  ActivityIndicator,
  Alert,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { useAuth } from '../context/AuthContext';
import FriendCard from '../components/FriendCard';
import {
  syncContactsAndFindSuggestions,
  markContactsSyncCompleted,
} from '../services/firebase/contactSyncService';
import { sendFriendRequest } from '../services/firebase/friendshipService';
import { mediumImpact } from '../utils/haptics';
import { colors } from '../constants/colors';
import { styles } from '../styles/ContactsSyncScreen.styles';
import logger from '../utils/logger';

/**
 * ContactsSyncScreen - Onboarding screen for syncing contacts and finding friends
 *
 * Flow:
 * 1. Show privacy-first messaging with "Sync Contacts" button
 * 2. On sync: request permission, fetch contacts, find matches
 * 3. Show results: friend suggestions with "Add" buttons
 * 4. Empty state: no matches found, encourage sharing
 * 5. Continue to main app
 */
const ContactsSyncScreen = ({ navigation }) => {
  const { user, userProfile, refreshUserProfile } = useAuth();
  const [screenState, setScreenState] = useState('initial'); // initial, syncing, results, empty
  const [suggestions, setSuggestions] = useState([]);
  const [addedUsers, setAddedUsers] = useState(new Set());
  const [actionLoading, setActionLoading] = useState({});

  /**
   * Handle sync contacts button press
   */
  const handleSyncContacts = async () => {
    try {
      setScreenState('syncing');
      mediumImpact();

      const result = await syncContactsAndFindSuggestions(
        user.uid,
        userProfile?.phoneNumber
      );

      if (!result.success) {
        if (result.error === 'permission_denied_permanent') {
          // User permanently denied - they need to go to settings
          setScreenState('initial');
          return;
        }
        if (result.error === 'permission_denied') {
          // User denied this time
          setScreenState('initial');
          return;
        }
        Alert.alert('Error', 'Failed to sync contacts. Please try again.');
        setScreenState('initial');
        return;
      }

      // Mark sync as completed
      await markContactsSyncCompleted(user.uid, true);

      if (result.suggestions.length === 0) {
        setScreenState('empty');
      } else {
        setSuggestions(result.suggestions);
        setScreenState('results');
      }
    } catch (error) {
      logger.error('Error syncing contacts', error);
      Alert.alert('Error', 'Something went wrong. Please try again.');
      setScreenState('initial');
    }
  };

  /**
   * Handle add friend
   */
  const handleAddFriend = async (userId) => {
    try {
      setActionLoading((prev) => ({ ...prev, [userId]: true }));
      mediumImpact();

      const result = await sendFriendRequest(user.uid, userId);

      if (result.success) {
        setAddedUsers((prev) => new Set([...prev, userId]));
      } else {
        Alert.alert('Error', result.error || 'Failed to send friend request');
      }
    } catch (error) {
      logger.error('Error adding friend', error);
      Alert.alert('Error', 'Failed to send friend request');
    } finally {
      setActionLoading((prev) => ({ ...prev, [userId]: false }));
    }
  };

  /**
   * Handle skip/continue - mark sync as skipped and proceed to main app
   */
  const handleSkip = async () => {
    mediumImpact();
    // Don't mark as completed - user skipped
    await refreshUserProfile();
    // Navigation will auto-transition via auth state listener
  };

  /**
   * Handle continue after results/empty
   */
  const handleContinue = async () => {
    mediumImpact();
    await refreshUserProfile();
    // Navigation will auto-transition via auth state listener
  };

  /**
   * Render initial state with privacy messaging
   */
  const renderInitialState = () => (
    <View style={styles.content}>
      <View style={styles.privacySection}>
        <Ionicons
          name="people-outline"
          size={64}
          color={colors.brand.purple}
          style={styles.privacyIcon}
        />
        <Text style={styles.privacyTitle}>Find Your Friends</Text>
        <Text style={styles.privacyText}>
          See which of your contacts are already on REWIND. Your contacts stay on your device — we only match phone numbers to find friends.
        </Text>
        <TouchableOpacity
          style={styles.syncButton}
          onPress={handleSyncContacts}
          activeOpacity={0.7}
        >
          <Text style={styles.syncButtonText}>Sync Contacts</Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={styles.skipButton}
          onPress={handleSkip}
          activeOpacity={0.7}
        >
          <Text style={styles.skipButtonText}>Skip for now</Text>
        </TouchableOpacity>
      </View>
    </View>
  );

  /**
   * Render syncing/loading state
   */
  const renderSyncingState = () => (
    <View style={styles.loadingContainer}>
      <ActivityIndicator size="large" color={colors.brand.purple} />
      <Text style={styles.loadingText}>Finding your friends...</Text>
    </View>
  );

  /**
   * Render results with suggestions
   */
  const renderResultsState = () => {
    const addedCount = addedUsers.size;

    return (
      <View style={styles.content}>
        <View style={styles.resultsHeader}>
          <Text style={styles.resultsTitle}>
            {suggestions.length} {suggestions.length === 1 ? 'Friend' : 'Friends'} Found
          </Text>
          <Text style={styles.resultsSubtitle}>
            {addedCount > 0
              ? `${addedCount} added • Tap to add more`
              : 'Tap Add to send friend requests'}
          </Text>
        </View>
        <FlatList
          data={suggestions}
          renderItem={({ item }) => {
            const isAdded = addedUsers.has(item.id);
            return (
              <FriendCard
                user={{
                  userId: item.id,
                  displayName: item.displayName,
                  username: item.username,
                  profilePhotoURL: item.profilePhotoURL || item.photoURL,
                }}
                relationshipStatus={isAdded ? 'pending_sent' : 'none'}
                onAction={(userId) => handleAddFriend(userId)}
                loading={actionLoading[item.id]}
              />
            );
          }}
          keyExtractor={(item) => item.id}
          contentContainerStyle={styles.listContent}
          showsVerticalScrollIndicator={false}
        />
        <View style={styles.continueContainer}>
          <TouchableOpacity
            style={styles.continueButton}
            onPress={handleContinue}
            activeOpacity={0.7}
          >
            <Text style={styles.continueButtonText}>Continue</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  };

  /**
   * Render empty state (no matches)
   */
  const renderEmptyState = () => (
    <View style={styles.content}>
      <View style={styles.emptyContainer}>
        <Ionicons
          name="heart-outline"
          size={64}
          color={colors.text.tertiary}
          style={styles.emptyIcon}
        />
        <Text style={styles.emptyTitle}>No Friends Found Yet</Text>
        <Text style={styles.emptyText}>
          None of your contacts are on REWIND yet. Invite them to join so you can share moments together!
        </Text>
      </View>
      <View style={styles.continueContainer}>
        <TouchableOpacity
          style={styles.continueButton}
          onPress={handleContinue}
          activeOpacity={0.7}
        >
          <Text style={styles.continueButtonText}>Continue</Text>
        </TouchableOpacity>
      </View>
    </View>
  );

  /**
   * Render content based on screen state
   */
  const renderContent = () => {
    switch (screenState) {
      case 'syncing':
        return renderSyncingState();
      case 'results':
        return renderResultsState();
      case 'empty':
        return renderEmptyState();
      default:
        return renderInitialState();
    }
  };

  return (
    <SafeAreaView style={styles.container} edges={['top']}>
      {/* Header */}
      <View style={styles.header}>
        <TouchableOpacity
          onPress={() => navigation.goBack()}
          style={styles.backButton}
          hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
        >
          <Ionicons name="chevron-back" size={28} color={colors.text.primary} />
        </TouchableOpacity>
        <Text style={styles.headerTitle}>Find Friends</Text>
      </View>

      {renderContent()}
    </SafeAreaView>
  );
};

export default ContactsSyncScreen;
````

3. Export from src/screens/index.js:
   Add `export { default as ContactsSyncScreen } from './ContactsSyncScreen';`
   </action>
   <verify>

- `npm start` runs without errors
- ContactsSyncScreen.js exists and compiles
- Styles file exists
- Screen exported from index.js
  </verify>
  <done>
- ContactsSyncScreen.js created with all states: initial, syncing, results, empty
- Privacy-first messaging with "contacts stay on device" text
- FriendCard integration for consistent suggestion display
- Continue/Skip buttons for navigation flow
- Styles follow existing patterns
  </done>
  </task>

<task type="auto">
  <name>Task 2: Integrate ContactsSyncScreen into onboarding navigation flow</name>
  <files>src/navigation/AppNavigator.js</files>
  <action>
Update AppNavigator.js to add ContactsSyncScreen to the onboarding flow:

1. Import ContactsSyncScreen:

```javascript
import ContactsSyncScreen from '../screens/ContactsSyncScreen';
```

2. Add ContactsSyncScreen to OnboardingStackNavigator (after Selects):

```javascript
const OnboardingStackNavigator = ({ initialRouteName }) => {
  return (
    <Stack.Navigator
      initialRouteName={initialRouteName}
      screenOptions={{
        headerShown: false,
        gestureEnabled: true,
        gestureDirection: 'horizontal',
        contentStyle: { backgroundColor: colors.background.primary },
      }}
    >
      <Stack.Screen name="ProfileSetup" component={ProfileSetupScreen} />
      <Stack.Screen name="Selects" component={SelectsScreen} />
      <Stack.Screen name="ContactsSync" component={ContactsSyncScreen} />
      <Stack.Screen
        name="SongSearch"
        component={SongSearchScreen}
        options={{
          presentation: 'card',
          animation: 'slide_from_bottom',
        }}
      />
    </Stack.Navigator>
  );
};
```

3. Update onboarding flow detection to include contacts sync step:

Find the section that determines `needsOnboarding` and update:

```javascript
// Show Selects if user completed profile setup but hasn't completed selects
const needsSelects =
  isAuthenticated &&
  userProfile &&
  userProfile.profileSetupCompleted === true &&
  userProfile.selectsCompleted !== true;

// Show ContactsSync if user completed selects but hasn't synced contacts
// Note: contactsSyncCompleted can be true (synced) or false (skipped) - both mean done
// Only show if contactsSyncCompleted is undefined (never prompted)
const needsContactsSync =
  isAuthenticated &&
  userProfile &&
  userProfile.profileSetupCompleted === true &&
  userProfile.selectsCompleted === true &&
  userProfile.contactsSyncCompleted === undefined;

// Determine if user needs onboarding
const needsOnboarding = needsProfileSetup || needsSelects || needsContactsSync;

// Start at appropriate screen
let onboardingInitialRoute = 'ProfileSetup';
if (needsContactsSync) {
  onboardingInitialRoute = 'ContactsSync';
} else if (needsSelects) {
  onboardingInitialRoute = 'Selects';
}
```

4. Update deep linking config to include ContactsSync:

```javascript
Onboarding: {
  screens: {
    ProfileSetup: 'profile-setup',
    Selects: 'selects',
    ContactsSync: 'contacts-sync',
  },
},
```

  </action>
  <verify>
- `npm start` runs without errors
- New users go through: ProfileSetup -> Selects -> ContactsSync -> MainTabs
- Users who completed selects but not contacts sync go directly to ContactsSync
- Skipping contacts sync still allows proceeding to main app
  </verify>
  <done>
- ContactsSyncScreen added to OnboardingStackNavigator
- Onboarding flow updated: ProfileSetup -> Selects -> ContactsSync -> MainTabs
- contactsSyncCompleted field determines if contacts sync step is needed
- Deep linking config updated
  </done>
</task>

<task type="auto">
  <name>Task 3: Update SelectsScreen to navigate to ContactsSync instead of main app</name>
  <files>src/screens/SelectsScreen.js</files>
  <action>
Update SelectsScreen to navigate to ContactsSync after completion:

1. Find the completion handler in SelectsScreen (handleComplete or similar function that marks selectsCompleted)

2. After marking selectsCompleted = true, navigate to ContactsSync:

The current flow likely calls refreshUserProfile() which triggers auth state change and navigation.

Instead, after setting selectsCompleted:

```javascript
// Navigate to ContactsSync screen
navigation.navigate('ContactsSync');
```

OR if using the auth state listener pattern, ensure the onboarding initial route detection is correct (handled in Task 2).

3. If SelectsScreen uses navigation.replace or navigation.reset, update to navigate('ContactsSync') to keep the stack.

Look for code like:

```javascript
// Current (probably):
await refreshUserProfile();
// Auth listener handles navigation

// This should work if Task 2's onboardingInitialRoute logic is correct
```

Verify the navigation flow works correctly by checking the auth state detection in AppNavigator handles the intermediate state where:

- profileSetupCompleted = true
- selectsCompleted = true
- contactsSyncCompleted = undefined
  </action>
  <verify>
- After completing Selects, user is taken to ContactsSync screen
- Back button on ContactsSync goes back to Selects
- Complete flow: ProfileSetup -> Selects -> ContactsSync -> MainTabs
  </verify>
  <done>
- SelectsScreen completion navigates to ContactsSync
- Onboarding flow is sequential and back navigation works
- Auth state properly handles all intermediate states
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm start` runs without errors
- [ ] ContactsSyncScreen displays with privacy messaging
- [ ] Sync contacts triggers permission request
- [ ] Results show matched users with FriendCard
- [ ] Add button sends friend request
- [ ] Empty state shows when no matches
- [ ] Skip proceeds to main app
- [ ] Continue proceeds to main app
- [ ] Full onboarding flow: ProfileSetup -> Selects -> ContactsSync -> MainTabs
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- ContactsSyncScreen provides complete onboarding experience
- Privacy messaging is clear and prominent
- Navigation flow is seamless
  </success_criteria>

<output>
After completion, create `.planning/phases/20-friend-suggestions-contacts-sync/20-02-SUMMARY.md`
</output>
