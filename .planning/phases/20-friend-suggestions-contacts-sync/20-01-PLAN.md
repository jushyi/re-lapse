---
phase: 20-friend-suggestions-contacts-sync
plan: 01
type: execute
---

<objective>
Build the contact sync data layer with phone normalization, permission handling, and user matching.

Purpose: Establish the service infrastructure for syncing device contacts and matching them against existing app users to generate friend suggestions.
Output: contactSyncService.js with full contact sync workflow, Firestore user document updates for sync state tracking.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-friend-suggestions-contacts-sync/20-CONTEXT.md
@.planning/phases/20-friend-suggestions-contacts-sync/20-RESEARCH.md

# Key source files:

@src/services/firebase/friendshipService.js
@src/services/firebase/phoneAuthService.js
@src/constants/colors.js

**Tech stack available:**

- libphonenumber-js (already installed) for E.164 normalization
- expo-contacts (needs install) for device contact access
- @react-native-firebase/firestore for user queries

**Established patterns:**

- Service layer: async functions returning { success: boolean, data/error }
- Firestore batched queries with IN limit of 30
- E.164 phone format already used in phoneAuthService.js

**Constraining decisions:**

- Phone numbers stored in E.164 format in user documents (existing)
- One-time sync only (no auto re-sync) per CONTEXT.md
- Direct contacts matching (no friends-of-friends) per CONTEXT.md
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Install expo-contacts and create contactSyncService</name>
  <files>package.json, src/services/firebase/contactSyncService.js, src/services/firebase/index.js</files>
  <action>
1. Install expo-contacts: `npx expo install expo-contacts`

2. Create contactSyncService.js with:

**Phone normalization helper:**

```javascript
import { parsePhoneNumberFromString } from 'libphonenumber-js';

export const normalizeToE164 = (phoneNumber, defaultCountry = 'US') => {
  if (!phoneNumber) return null;
  try {
    const parsed = parsePhoneNumberFromString(phoneNumber, defaultCountry);
    if (parsed && parsed.isValid()) {
      return parsed.format('E.164');
    }
    return null;
  } catch {
    return null;
  }
};
```

**Permission handling:**

```javascript
import * as Contacts from 'expo-contacts';
import { Alert, Linking } from 'react-native';

export const requestContactsPermission = async () => {
  const { status, canAskAgain } = await Contacts.requestPermissionsAsync();

  if (status === 'granted') {
    return { granted: true };
  }

  if (status === 'denied' && !canAskAgain) {
    // Permanently denied - guide to settings
    Alert.alert(
      'Contacts Access Required',
      'To find friends, please enable Contacts access in Settings.',
      [
        { text: 'Cancel', style: 'cancel' },
        { text: 'Open Settings', onPress: () => Linking.openSettings() },
      ]
    );
    return { granted: false, permanent: true };
  }

  return { granted: false, permanent: false };
};

export const checkContactsPermission = async () => {
  const { status } = await Contacts.getPermissionsAsync();
  return status === 'granted';
};
```

**Contact fetching with pagination:**

```javascript
export const getAllContactPhoneNumbers = async (defaultCountry = 'US') => {
  const PAGE_SIZE = 100;
  const allPhoneNumbers = new Set();
  let hasNextPage = true;
  let pageOffset = 0;

  while (hasNextPage) {
    const { data, hasNextPage: more } = await Contacts.getContactsAsync({
      fields: [Contacts.Fields.PhoneNumbers],
      pageSize: PAGE_SIZE,
      pageOffset,
    });

    for (const contact of data) {
      if (contact.phoneNumbers) {
        for (const phone of contact.phoneNumbers) {
          const normalized = normalizeToE164(phone.number, defaultCountry);
          if (normalized) {
            allPhoneNumbers.add(normalized);
          }
        }
      }
    }

    hasNextPage = more;
    pageOffset += PAGE_SIZE;
  }

  return Array.from(allPhoneNumbers);
};
```

**Batched user lookup (Firestore IN limit = 30):**

```javascript
export const findUsersByPhoneNumbers = async phoneNumbers => {
  if (!phoneNumbers.length) return [];

  const BATCH_SIZE = 30;
  const batches = [];

  for (let i = 0; i < phoneNumbers.length; i += BATCH_SIZE) {
    batches.push(phoneNumbers.slice(i, i + BATCH_SIZE));
  }

  const results = await Promise.all(
    batches.map(async batch => {
      const usersRef = collection(db, 'users');
      const q = query(usersRef, where('phoneNumber', 'in', batch));
      const snapshot = await getDocs(q);
      return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
    })
  );

  return results.flat();
};
```

3. Export new service in src/services/firebase/index.js

Follow existing service patterns (logger, error handling, return format).
</action>
<verify>

- `npm start` runs without errors
- Service file exists with all functions exported
- expo-contacts added to package.json dependencies
  </verify>
  <done>
- contactSyncService.js created with: normalizeToE164, requestContactsPermission, checkContactsPermission, getAllContactPhoneNumbers, findUsersByPhoneNumbers
- expo-contacts installed
- Service exported from index.js
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add contact sync orchestration and suggestion filtering</name>
  <files>src/services/firebase/contactSyncService.js</files>
  <action>
Add the main orchestration function and suggestion filtering:

**Get user's country from their phone number:**

```javascript
export const getUserCountryCode = userPhoneNumber => {
  if (!userPhoneNumber) return 'US';
  try {
    const parsed = parsePhoneNumberFromString(userPhoneNumber);
    return parsed?.country || 'US';
  } catch {
    return 'US';
  }
};
```

**Get existing friend/pending IDs to filter out:**

```javascript
import { getFriendships, getPendingRequests, getSentRequests } from './friendshipService';

const getExistingRelationshipIds = async userId => {
  const [friendsResult, incomingResult, sentResult] = await Promise.all([
    getFriendships(userId),
    getPendingRequests(userId),
    getSentRequests(userId),
  ]);

  const ids = new Set();

  // Add friend user IDs
  if (friendsResult.success) {
    friendsResult.friendships.forEach(f => {
      ids.add(f.user1Id === userId ? f.user2Id : f.user1Id);
    });
  }

  // Add incoming request user IDs
  if (incomingResult.success) {
    incomingResult.requests.forEach(r => {
      ids.add(r.user1Id === userId ? r.user2Id : r.user1Id);
    });
  }

  // Add sent request user IDs
  if (sentResult.success) {
    sentResult.requests.forEach(r => {
      ids.add(r.user1Id === userId ? r.user2Id : r.user1Id);
    });
  }

  return ids;
};
```

**Main sync orchestration:**

```javascript
export const syncContactsAndFindSuggestions = async (currentUserId, userPhoneNumber) => {
  try {
    // 1. Request permission
    const { granted, permanent } = await requestContactsPermission();
    if (!granted) {
      return {
        success: false,
        error: permanent ? 'permission_denied_permanent' : 'permission_denied',
      };
    }

    // 2. Get user's country for phone parsing
    const defaultCountry = getUserCountryCode(userPhoneNumber);

    // 3. Get all contact phone numbers (normalized)
    const contactPhoneNumbers = await getAllContactPhoneNumbers(defaultCountry);

    // 4. Remove user's own phone number
    const filteredPhoneNumbers = contactPhoneNumbers.filter(phone => phone !== userPhoneNumber);

    if (filteredPhoneNumbers.length === 0) {
      return { success: true, suggestions: [], noContacts: true };
    }

    // 5. Find matching users in database
    const matchedUsers = await findUsersByPhoneNumbers(filteredPhoneNumbers);

    // 6. Filter out self, existing friends, pending requests
    const existingIds = await getExistingRelationshipIds(currentUserId);

    const suggestions = matchedUsers.filter(
      user => user.id !== currentUserId && !existingIds.has(user.id)
    );

    return { success: true, suggestions };
  } catch (error) {
    logger.error('Error syncing contacts', error);
    return { success: false, error: error.message };
  }
};
```

**Get dismissed suggestions for a user:**

```javascript
export const getDismissedSuggestionIds = async userId => {
  try {
    const userRef = doc(db, 'users', userId);
    const userDoc = await getDoc(userRef);

    if (userDoc.exists()) {
      return userDoc.data().dismissedSuggestions || [];
    }
    return [];
  } catch (error) {
    logger.error('Error getting dismissed suggestions', error);
    return [];
  }
};

export const filterDismissedSuggestions = (suggestions, dismissedIds = []) => {
  const dismissedSet = new Set(dismissedIds);
  return suggestions.filter(s => !dismissedSet.has(s.id));
};
```

  </action>
  <verify>
- Service file compiles without errors
- All new functions exported
  </verify>
  <done>
- syncContactsAndFindSuggestions function orchestrates full flow
- getExistingRelationshipIds filters out friends/pending
- getDismissedSuggestionIds and filterDismissedSuggestions handle dismissed suggestions
  </done>
</task>

<task type="auto">
  <name>Task 3: Add user document updates for sync state and dismissals</name>
  <files>src/services/firebase/contactSyncService.js</files>
  <action>
Add functions to update user documents for tracking sync state and dismissals:

**Dismiss a suggestion:**

```javascript
import { updateDoc, arrayUnion } from '@react-native-firebase/firestore';

export const dismissSuggestion = async (userId, dismissedUserId) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      dismissedSuggestions: arrayUnion(dismissedUserId),
    });
    return { success: true };
  } catch (error) {
    logger.error('Error dismissing suggestion', error);
    return { success: false, error: error.message };
  }
};
```

**Mark contacts sync as completed:**

```javascript
export const markContactsSyncCompleted = async (userId, completed = true) => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      contactsSyncCompleted: completed,
      contactsSyncedAt: completed ? serverTimestamp() : null,
    });
    return { success: true };
  } catch (error) {
    logger.error('Error marking contacts sync completed', error);
    return { success: false, error: error.message };
  }
};
```

**Check if user has synced contacts:**

```javascript
export const hasUserSyncedContacts = async userId => {
  try {
    const userRef = doc(db, 'users', userId);
    const userDoc = await getDoc(userRef);

    if (userDoc.exists()) {
      return userDoc.data().contactsSyncCompleted === true;
    }
    return false;
  } catch (error) {
    logger.error('Error checking contacts sync status', error);
    return false;
  }
};
```

**Clear dismissed suggestions (for re-sync):**

```javascript
export const clearDismissedSuggestions = async userId => {
  try {
    const userRef = doc(db, 'users', userId);
    await updateDoc(userRef, {
      dismissedSuggestions: [],
    });
    return { success: true };
  } catch (error) {
    logger.error('Error clearing dismissed suggestions', error);
    return { success: false, error: error.message };
  }
};
```

Ensure all imports are at top of file:

- doc, getDoc, updateDoc, arrayUnion, serverTimestamp, collection, query, where, getDocs from @react-native-firebase/firestore
- logger from '../../utils/logger'
  </action>
  <verify>
- All functions compile without errors
- Service exports all functions
- `npm start` runs successfully
  </verify>
  <done>
- dismissSuggestion stores dismissed user IDs in user document
- markContactsSyncCompleted tracks sync state with timestamp
- hasUserSyncedContacts checks if user has synced before
- clearDismissedSuggestions allows re-sync with fresh suggestions
- User document fields: contactsSyncCompleted (boolean), contactsSyncedAt (timestamp), dismissedSuggestions (array)
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm start` runs without errors
- [ ] expo-contacts installed and in package.json
- [ ] contactSyncService.js exists with all functions
- [ ] Service exported from src/services/firebase/index.js
- [ ] No TypeScript/lint errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- contactSyncService provides complete contact sync workflow
- Service follows established patterns (return format, logging, error handling)
  </success_criteria>

<output>
After completion, create `.planning/phases/20-friend-suggestions-contacts-sync/20-01-SUMMARY.md`
</output>
