---
phase: 25-color-palette
plan: 03
type: execute
domain: react-native
teaching: true
---

<objective>
Create the Appearance settings screen with theme selection grid and preview/apply flow.

Purpose: Give users a way to browse and select themes from Settings.
Output: AppearanceSettingsScreen with theme grid, preview state, and apply functionality.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-color-palette/25-CONTEXT.md
@src/context/ThemeContext.js
@src/constants/themes.js
@src/components/ThemeCard.js
@src/screens/SettingsScreen.js
@.planning/phases/25-color-palette/25-02-SUMMARY.md (if exists)

**Current State:**

- ThemeContext provides themes list and setTheme function
- ThemeCard component ready for displaying theme options
- SettingsScreen exists and needs "Appearance" section

**This Plan Creates:**

- AppearanceSettingsScreen with theme grid
- Preview → Apply flow (select shows preview, explicit apply to confirm)
- Navigation from Settings to Appearance
  </context>

<learning_objectives>
By the end of this plan, you will:

1. Create a new screen following project patterns
2. Implement preview state (showing changes without committing)
3. Learn navigation patterns (stack navigation, back handling)
4. Build a grid layout with FlatList
   </learning_objectives>

<tasks>

<task type="auto">
  <name>Task 1: Create AppearanceSettingsScreen</name>
  <files>src/screens/AppearanceSettingsScreen.js, src/styles/AppearanceSettingsScreen.styles.js</files>
  <action>
**Create the Appearance settings screen with theme selection.**

**Screen layout:**

```
┌─────────────────────────────┐
│  < Appearance               │  <- Header with back button
├─────────────────────────────┤
│                             │
│  Select a theme             │  <- Section title
│                             │
│  ┌─────┐ ┌─────┐ ┌─────┐   │
│  │Dark │ │Light│ │Ocean│   │  <- Theme grid (2 or 3 columns)
│  └─────┘ └─────┘ └─────┘   │
│  ┌─────┐ ┌─────┐           │
│  │Forest│ │Sunset│          │
│  └─────┘ └─────┘           │
│                             │
│  ┌─────────────────────┐   │
│  │    Custom Theme      │   │  <- Button to custom editor (Plan 04)
│  └─────────────────────┘   │
│                             │
│                             │
│  ┌─────────────────────┐   │
│  │       Apply         │   │  <- Apply button (only shown when preview active)
│  └─────────────────────┘   │
│                             │
└─────────────────────────────┘
```

**Key behavior - Preview flow:**

1. User taps a theme card
2. App shows that theme as a preview (but doesn't persist yet)
3. User sees the app with preview theme
4. "Apply" button appears
5. User taps Apply → theme is saved and persisted
6. If user navigates away without applying → reverts to previous theme

**Implementation structure:**

```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, FlatList, TouchableOpacity, StyleSheet } from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { useTheme } from '../context/ThemeContext';
import ThemeCard from '../components/ThemeCard';
import { colors } from '../constants/colors';

const AppearanceSettingsScreen = () => {
  const navigation = useNavigation();
  const { theme, themes, currentThemeId, setTheme } = useTheme();

  // Preview state - theme being previewed but not yet applied
  const [previewThemeId, setPreviewThemeId] = useState(null);
  // Track original theme to revert if user cancels
  const [originalThemeId, setOriginalThemeId] = useState(currentThemeId);

  // On mount, store original theme for potential revert
  useEffect(() => {
    setOriginalThemeId(currentThemeId);
  }, []);

  // Handle back navigation - revert if not applied
  useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', e => {
      if (previewThemeId && previewThemeId !== originalThemeId) {
        // Revert to original theme
        setTheme(originalThemeId);
      }
    });
    return unsubscribe;
  }, [navigation, previewThemeId, originalThemeId]);

  const handleThemeSelect = themeId => {
    setPreviewThemeId(themeId);
    setTheme(themeId); // Apply preview (not persisted until Apply pressed)
  };

  const handleApply = async () => {
    // setTheme already called in handleThemeSelect
    // This persists and clears preview state
    setOriginalThemeId(previewThemeId);
    setPreviewThemeId(null);
    navigation.goBack();
  };

  // Determine which theme is visually selected
  const selectedThemeId = previewThemeId || currentThemeId;

  return (
    <View style={styles.container}>
      {/* Theme grid */}
      <FlatList
        data={themes}
        numColumns={2}
        keyExtractor={item => item.id}
        renderItem={({ item }) => (
          <ThemeCard
            theme={item}
            isSelected={item.id === selectedThemeId}
            onPress={() => handleThemeSelect(item.id)}
          />
        )}
        contentContainerStyle={styles.grid}
        ListHeaderComponent={<Text style={styles.sectionTitle}>Select a theme</Text>}
        ListFooterComponent={
          <TouchableOpacity
            style={styles.customButton}
            onPress={() => navigation.navigate('CustomThemeEditor')}
          >
            <Text style={styles.customButtonText}>Create Custom Theme</Text>
          </TouchableOpacity>
        }
      />

      {/* Apply button - only show when preview active */}
      {previewThemeId && previewThemeId !== originalThemeId && (
        <TouchableOpacity style={styles.applyButton} onPress={handleApply}>
          <Text style={styles.applyButtonText}>Apply Theme</Text>
        </TouchableOpacity>
      )}
    </View>
  );
};

// Styles - use colors from theme context where possible
const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: colors.background.primary,
  },
  sectionTitle: {
    color: colors.text.primary,
    fontSize: 18,
    fontWeight: '600',
    marginBottom: 16,
    marginLeft: 4,
  },
  grid: {
    padding: 16,
  },
  customButton: {
    marginTop: 24,
    padding: 16,
    borderRadius: 12,
    borderWidth: 1,
    borderStyle: 'dashed',
    borderColor: colors.border.subtle,
    alignItems: 'center',
  },
  customButtonText: {
    color: colors.text.secondary,
    fontSize: 16,
  },
  applyButton: {
    position: 'absolute',
    bottom: 40,
    left: 16,
    right: 16,
    backgroundColor: colors.interactive.primary,
    padding: 16,
    borderRadius: 12,
    alignItems: 'center',
  },
  applyButtonText: {
    color: colors.text.primary,
    fontSize: 16,
    fontWeight: '600',
  },
});

export default AppearanceSettingsScreen;
```

**Learning hint - Preview vs Apply pattern:**
This is a common UX pattern where users can "try before they buy":

1. Preview: Change is visible but not saved
2. Apply: Change is saved/persisted
3. Cancel: Revert to original state

We track this with:

- `previewThemeId`: The theme being previewed
- `originalThemeId`: The theme to revert to if cancelled
- Navigation listener to handle back button

**Note:** The "Custom Theme" button will navigate to a screen we create in Plan 04.
</action>
<verify>

1. Screen renders without errors
2. Theme grid shows all 5 themes
3. Tapping a theme shows selection state
4. "Create Custom Theme" button visible at bottom of grid
5. Apply button appears when preview is active
   </verify>
   <done>AppearanceSettingsScreen created with theme grid and preview/apply flow</done>
   </task>

<task type="auto">
  <name>Task 2: Add navigation from Settings to Appearance</name>
  <files>src/screens/SettingsScreen.js, src/navigation/AppNavigator.js</files>
  <action>
**Wire up navigation to the new Appearance screen.**

**1. Register screen in AppNavigator.js:**

Find the Settings stack or main stack and add:

```javascript
import AppearanceSettingsScreen from '../screens/AppearanceSettingsScreen';

// In the Stack.Navigator:
<Stack.Screen
  name="AppearanceSettings"
  component={AppearanceSettingsScreen}
  options={{
    title: 'Appearance',
    headerStyle: { backgroundColor: colors.background.primary },
    headerTintColor: colors.text.primary,
  }}
/>;
```

**2. Add Appearance row in SettingsScreen.js:**

Find the settings list and add an "Appearance" option:

```javascript
// In the settings items:
{
  title: 'Appearance',
  icon: 'color-palette-outline', // Ionicons
  onPress: () => navigation.navigate('AppearanceSettings'),
}
```

**Learning hint - Where to add the screen:**
Look at how other screens are registered in AppNavigator.js. You'll likely see a pattern like:

- Main tabs (Feed, Camera, Profile)
- Stack screens that can be pushed on top

The AppearanceSettings screen should be in the same stack as the SettingsScreen so the back button works naturally.

**If SettingsScreen uses a list pattern:**

```javascript
const settingsItems = [
  // Existing items...
  {
    title: 'Appearance',
    icon: 'color-palette-outline',
    onPress: () => navigation.navigate('AppearanceSettings'),
  },
  // More items...
];
```

  </action>
  <verify>
1. Navigate to Settings tab
2. "Appearance" option visible in settings list
3. Tapping "Appearance" navigates to AppearanceSettingsScreen
4. Back button returns to Settings
5. Header shows "Appearance" title
  </verify>
  <done>Navigation wired from Settings to Appearance screen</done>
</task>

<task type="auto">
  <name>Task 3: Update ThemeCard layout for grid display</name>
  <files>src/components/ThemeCard.js</files>
  <action>
**Adjust ThemeCard dimensions and styling for 2-column grid.**

The current ThemeCard might need adjustments to look good in a 2-column FlatList:

**Sizing considerations:**

- Screen width / 2 - padding = card width
- Common pattern: `(screenWidth - 48) / 2` for 16px outer padding + 16px gap

**Update styles:**

```javascript
import { Dimensions } from 'react-native';

const SCREEN_WIDTH = Dimensions.get('window').width;
const CARD_WIDTH = (SCREEN_WIDTH - 48) / 2; // 16px padding each side + 16px gap

const styles = StyleSheet.create({
  card: {
    width: CARD_WIDTH,
    height: CARD_WIDTH * 1.2, // Slightly taller than wide
    backgroundColor: colors.background.card,
    borderRadius: 12,
    padding: 8,
    marginBottom: 16,
    marginHorizontal: 4,
    borderWidth: 2,
    borderColor: 'transparent',
  },
  cardSelected: {
    borderColor: colors.interactive.primary,
  },
  // ... rest of styles
});
```

**Add margin handling in FlatList:**
The FlatList columnWrapperStyle can help with spacing:

```javascript
// In AppearanceSettingsScreen:
<FlatList
  columnWrapperStyle={styles.row}
  // ...
/>

// In styles:
row: {
  justifyContent: 'space-between',
},
```

  </action>
  <verify>
1. Cards display in 2-column grid
2. Cards are evenly spaced
3. Cards don't overflow screen edges
4. Selection border visible when selected
  </verify>
  <done>ThemeCard properly sized for grid layout</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Appearance settings screen with theme selection and preview/apply flow</what-built>
  <how-to-verify>
1. Run the app: `npx expo start`
2. Navigate to Profile → Settings
3. Tap "Appearance"
4. Verify:
   - All 5 themes shown in grid
   - Current theme (Dark) shows selected state
5. Tap "Light" theme
   - Selection moves to Light
   - App background changes to white
   - "Apply Theme" button appears at bottom
6. Tap the back button WITHOUT applying
   - App should revert to Dark theme
7. Go back to Appearance, select Light again
8. Tap "Apply Theme"
   - Theme is saved
   - Navigates back to Settings
9. Go to Appearance again
   - Light should still be selected (persisted)
10. Switch back to Dark and apply

**Test preview/revert behavior thoroughly!**
</how-to-verify>
<resume-signal>Type "settings UI approved" if working correctly, or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] AppearanceSettingsScreen created
- [ ] Navigation from Settings works
- [ ] Theme grid displays all themes
- [ ] Preview shows theme changes without persisting
- [ ] Apply button saves and navigates back
- [ ] Back navigation reverts preview
</verification>

<success_criteria>

- Users can access Appearance from Settings
- Users can preview themes before applying
- Apply button saves theme choice
- Back button reverts preview to original
- Theme persists after app restart
  </success_criteria>

<output>
After completion, create `.planning/phases/25-color-palette/25-03-SUMMARY.md`:

# Phase 25 Plan 03: Settings UI Summary

**[One-liner describing what was accomplished]**

## Files Created/Modified

- `src/screens/AppearanceSettingsScreen.js` - Theme selection screen (NEW)
- `src/screens/SettingsScreen.js` - Added Appearance navigation
- `src/navigation/AppNavigator.js` - Registered new screen
- `src/components/ThemeCard.js` - Adjusted for grid layout

## Key Patterns Learned

- Preview → Apply UX pattern
- Navigation listeners for cancel handling
- FlatList grid with numColumns

## Next Step

Ready for 25-04-PLAN.md (Custom Palette Editor)
</output>
