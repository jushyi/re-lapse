---
phase: 25-color-palette
plan: 02
type: execute
domain: documentation
---

<objective>
Create implementation guide documents for ThemeCard component and theme system expansion.

Purpose: Produce step-by-step tutorials with code examples, hints, and solutions for the junior developer.
Output: 02-THEME-CARD.md and 03-THEME-SYSTEM.md in docs/phase-25/
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/25-color-palette/25-CONTEXT.md
@src/context/ThemeContext.js
@src/constants/colors.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThemeCard component guide</name>
  <files>docs/phase-25/02-THEME-CARD.md</files>
  <action>
Create the first component tutorial:

```markdown
# Building the ThemeCard Component

Your first task is creating a reusable component that displays a theme preview. This card will be used in the theme selection UI.

## What You'll Build

A card that shows:

- A mini preview of 5 theme colors
- The theme name
- A selected/unselected state

## Component Requirements
```

Props:

- theme: { id, name, colors: { background, card, text, accent, accentSecondary } }
- isSelected: boolean
- onPress: function

Visual:

- Card dimensions: ~100x140 pixels
- Shows all 5 colors in the preview area
- Purple border when selected
- Subtle border when not selected

````

## Step 1: Create the File

Create a new file at `src/components/ThemeCard.js`:

```javascript
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';
import { colors } from '../constants/colors';

const ThemeCard = ({ theme, isSelected, onPress }) => {
  // We'll fill this in
  return null;
};

const styles = StyleSheet.create({
  // We'll add styles
});

export default ThemeCard;
````

## Step 2: Build the Structure

**Try it yourself first!** Think about:

- What's the outer wrapper? (Hint: needs to respond to taps)
- How will you show the 5 colors?
- Where does the theme name go?

<details>
<summary>ðŸ’¡ Hint</summary>

The structure should be:

```
TouchableOpacity (card wrapper)
  â””â”€â”€ View (preview area)
      â”œâ”€â”€ View (color row - accent, accentSecondary, text)
      â””â”€â”€ View (color row - card, background)
  â””â”€â”€ Text (theme name)
```

</details>

<details>
<summary>âœ… Solution</summary>

```javascript
const ThemeCard = ({ theme, isSelected, onPress }) => {
  return (
    <TouchableOpacity
      style={[styles.card, isSelected && styles.cardSelected]}
      onPress={onPress}
      activeOpacity={0.8}
    >
      {/* Color preview area */}
      <View style={[styles.preview, { backgroundColor: theme.colors.background }]}>
        {/* Top row: accent colors + text */}
        <View style={styles.colorRow}>
          <View style={[styles.colorSwatch, { backgroundColor: theme.colors.accent }]} />
          <View style={[styles.colorSwatch, { backgroundColor: theme.colors.accentSecondary }]} />
          <View style={[styles.colorSwatch, { backgroundColor: theme.colors.text }]} />
        </View>
        {/* Card color strip */}
        <View style={[styles.cardStrip, { backgroundColor: theme.colors.card }]} />
      </View>

      {/* Theme name */}
      <Text style={styles.themeName}>{theme.name}</Text>
    </TouchableOpacity>
  );
};
```

</details>

## Step 3: Add the Styles

**Try it yourself!** Create styles for:

- `card`: The outer container with border
- `cardSelected`: Purple border for selected state
- `preview`: The color preview area
- `colorRow`: Horizontal row of color swatches
- `colorSwatch`: Individual small color square
- `cardStrip`: Horizontal bar showing card color
- `themeName`: Text styling

<details>
<summary>ðŸ’¡ Hints</summary>

- Use `borderWidth: 2` for the card border
- For unselected, use `borderColor: colors.border.subtle`
- For selected, use `borderColor: colors.interactive.primary`
- Color swatches can be ~20x20 pixels
- The card strip can be ~8 pixels tall

</details>

<details>
<summary>âœ… Solution</summary>

```javascript
const styles = StyleSheet.create({
  card: {
    width: 100,
    backgroundColor: colors.background.card,
    borderRadius: 12,
    borderWidth: 2,
    borderColor: colors.border.subtle,
    overflow: 'hidden',
    marginRight: 12,
    marginBottom: 12,
  },
  cardSelected: {
    borderColor: colors.interactive.primary,
  },
  preview: {
    padding: 8,
    height: 80,
    justifyContent: 'space-between',
  },
  colorRow: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
  colorSwatch: {
    width: 20,
    height: 20,
    borderRadius: 4,
  },
  cardStrip: {
    height: 8,
    borderRadius: 4,
    marginTop: 8,
  },
  themeName: {
    color: colors.text.primary,
    fontSize: 12,
    fontWeight: '500',
    textAlign: 'center',
    paddingVertical: 8,
  },
});
```

</details>

## Step 4: Test Your Component

Temporarily add this to `src/screens/ProfileScreen.js` to test:

```javascript
// At the top, add:
import ThemeCard from '../components/ThemeCard';

// Inside the render, add temporarily:
<View style={{ padding: 20 }}>
  <ThemeCard
    theme={{
      id: 'dark',
      name: 'Dark',
      colors: {
        background: '#000000',
        card: '#111111',
        text: '#FFFFFF',
        accent: '#8B5CF6',
        accentSecondary: '#EC4899',
      },
    }}
    isSelected={true}
    onPress={() => console.log('Tapped!')}
  />
</View>;
```

### Verify:

- [ ] Card renders without errors
- [ ] All 5 colors are visible
- [ ] Theme name "Dark" appears
- [ ] Card has purple border (selected)
- [ ] Tapping logs "Tapped!" to console

### Test unselected state:

Change `isSelected={true}` to `isSelected={false}` and verify the border changes.

**Don't forget:** Remove the test code from ProfileScreen before moving on!

## Key Learnings

1. **Conditional styling:** `[styles.base, condition && styles.conditional]`
2. **TouchableOpacity:** Makes any view tappable
3. **Dynamic styles:** `{ backgroundColor: theme.colors.accent }`
4. **StyleSheet.create():** Always use this for performance

---

**Next:** [03-THEME-SYSTEM.md](./03-THEME-SYSTEM.md) - Expanding the theme context

````
  </action>
  <verify>docs/phase-25/02-THEME-CARD.md created with tutorial content</verify>
  <done>ThemeCard tutorial created</done>
</task>

<task type="auto">
  <name>Task 2: Create theme system expansion guide</name>
  <files>docs/phase-25/03-THEME-SYSTEM.md</files>
  <action>
Create the theme system tutorial:

```markdown
# Expanding the Theme System

Now we'll upgrade the theme system to support full theming with 5 customizable colors per theme.

## Current State vs. Goal

**Current:** ThemeContext only swaps accent colors (purple/pink variants)

**Goal:** Full theming with background, card, text, and accent colors

## Step 1: Create Theme Definitions

Create a new file `src/constants/themes.js`:

```javascript
/**
 * Theme Definitions
 * =================
 * Each theme defines 5 key colors:
 * - background: Main screen background
 * - card: Cards, modals, elevated surfaces
 * - text: Primary text color
 * - accent: Primary interactive color (buttons, highlights)
 * - accentSecondary: Secondary accent (gradients, highlights)
 */

export const THEMES = {
  dark: {
    id: 'dark',
    name: 'Dark',
    description: 'Default dark theme',
    colors: {
      background: '#000000',
      card: '#111111',
      text: '#FFFFFF',
      accent: '#8B5CF6',
      accentSecondary: '#EC4899',
    },
  },
  light: {
    id: 'light',
    name: 'Light',
    description: 'Clean light theme',
    colors: {
      background: '#FFFFFF',
      card: '#F5F5F5',
      text: '#000000',
      accent: '#8B5CF6',
      accentSecondary: '#EC4899',
    },
  },
  ocean: {
    id: 'ocean',
    name: 'Ocean',
    description: 'Deep blue tones',
    colors: {
      background: '#0A1628',
      card: '#1A2940',
      text: '#E0F2FE',
      accent: '#38BDF8',
      accentSecondary: '#22D3EE',
    },
  },
  forest: {
    id: 'forest',
    name: 'Forest',
    description: 'Natural green palette',
    colors: {
      background: '#0A1F0A',
      card: '#1A3A1A',
      text: '#E8F5E9',
      accent: '#4ADE80',
      accentSecondary: '#A3E635',
    },
  },
  sunset: {
    id: 'sunset',
    name: 'Sunset',
    description: 'Warm orange tones',
    colors: {
      background: '#1A0A0A',
      card: '#2D1515',
      text: '#FFF5F5',
      accent: '#F97316',
      accentSecondary: '#FBBF24',
    },
  },
};

export const DEFAULT_THEME_ID = 'dark';

export const getThemeList = () => Object.values(THEMES);

export const getTheme = (themeId) => THEMES[themeId] || THEMES[DEFAULT_THEME_ID];
````

### Why separate data from logic?

Keeping theme definitions separate from ThemeContext makes it easier to:

- Add new themes without touching context code
- Test theme data independently
- Import themes in components that only need the data

## Step 2: Update ThemeContext

Now update `src/context/ThemeContext.js` to use the new theme structure.

**Try it yourself!** You need to:

1. Import the new theme helpers
2. Change state from palette name to theme ID
3. Update the setTheme function
4. Build the theme object with all colors
5. Maintain backwards compatibility

<details>
<summary>ðŸ’¡ Key Changes</summary>

1. Import: `import { THEMES, DEFAULT_THEME_ID, getTheme, getThemeList } from '../constants/themes';`
2. State: `const [currentThemeId, setCurrentThemeId] = useState(DEFAULT_THEME_ID);`
3. setTheme should validate the theme ID exists
4. The theme object needs to merge with existing colors for backwards compatibility

</details>

<details>
<summary>âœ… Full Solution</summary>

```javascript
import React, { createContext, useState, useContext, useEffect } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { colors } from '../constants/colors';
import { THEMES, DEFAULT_THEME_ID, getTheme, getThemeList } from '../constants/themes';
import logger from '../utils/logger';

const THEME_STORAGE_KEY = '@rewind_theme_id';

const ThemeContext = createContext({});

export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context || Object.keys(context).length === 0) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

export const ThemeProvider = ({ children }) => {
  const [currentThemeId, setCurrentThemeId] = useState(DEFAULT_THEME_ID);
  const [initializing, setInitializing] = useState(true);

  // Load saved theme on mount
  useEffect(() => {
    const loadSavedTheme = async () => {
      try {
        const savedThemeId = await AsyncStorage.getItem(THEME_STORAGE_KEY);
        if (savedThemeId && THEMES[savedThemeId]) {
          setCurrentThemeId(savedThemeId);
        }
      } catch (error) {
        logger.warn('ThemeContext: Failed to load saved theme');
      } finally {
        setInitializing(false);
      }
    };
    loadSavedTheme();
  }, []);

  const setTheme = async themeId => {
    if (!THEMES[themeId]) {
      logger.warn('ThemeContext: Invalid theme ID', { themeId });
      return;
    }
    setCurrentThemeId(themeId);
    try {
      await AsyncStorage.setItem(THEME_STORAGE_KEY, themeId);
    } catch (error) {
      logger.warn('ThemeContext: Failed to persist theme');
    }
  };

  // Build theme object
  const currentTheme = getTheme(currentThemeId);
  const theme = {
    id: currentTheme.id,
    name: currentTheme.name,
    colors: currentTheme.colors,

    // Backwards compatibility - spread existing colors and override
    ...colors,
    background: {
      ...colors.background,
      primary: currentTheme.colors.background,
      secondary: currentTheme.colors.card,
      card: currentTheme.colors.card,
    },
    text: {
      ...colors.text,
      primary: currentTheme.colors.text,
    },
    brand: {
      ...colors.brand,
      purple: currentTheme.colors.accent,
      pink: currentTheme.colors.accentSecondary,
    },
    interactive: {
      ...colors.interactive,
      primary: currentTheme.colors.accent,
    },
  };

  const value = {
    theme,
    currentThemeId,
    setTheme,
    themes: getThemeList(),
    initializing,
  };

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
};
```

</details>

## Step 3: Update ThemeCard for Real Data

Update your ThemeCard to work with the actual theme objects from THEMES.

The props are already correct! The themes from `getThemeList()` have the exact structure your ThemeCard expects:

- `theme.id`
- `theme.name`
- `theme.colors.background`, etc.

## Verification Checklist

Test that the system works:

- [ ] App runs without errors
- [ ] Add `console.log(useTheme())` in any component - check the output includes `themes` array
- [ ] Navigate through the app - everything should still work (backwards compatible)
- [ ] No visual changes yet (we're still on dark theme)

## Key Learnings

1. **Separation of concerns:** Data in themes.js, logic in ThemeContext
2. **Backwards compatibility:** Spread existing values, then override specific ones
3. **Fallback patterns:** `THEMES[themeId] || THEMES[DEFAULT_THEME_ID]`
4. **Context value:** Provide everything consumers might need

---

**Next:** [04-SETTINGS-UI.md](./04-SETTINGS-UI.md) - Building the appearance settings screen

```
  </action>
  <verify>docs/phase-25/03-THEME-SYSTEM.md created</verify>
  <done>Theme system tutorial created</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] docs/phase-25/02-THEME-CARD.md created with full tutorial
- [ ] docs/phase-25/03-THEME-SYSTEM.md created with full tutorial
- [ ] Both have try-it-yourself sections with hints and solutions
- [ ] Verification checklists included
</verification>

<success_criteria>
- Junior developer can build ThemeCard by following guide
- Theme system expansion is clearly explained
- Code solutions provided with educational hints
</success_criteria>

<output>
After completion, create `.planning/phases/25-color-palette/25-02-SUMMARY.md`
</output>
```
