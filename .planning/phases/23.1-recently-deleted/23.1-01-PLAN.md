---
phase: 23.1-recently-deleted
plan: 01
type: execute
---

<objective>
Implement soft delete infrastructure for photos with 30-day grace period and scheduled cleanup.

Purpose: Enable Recently Deleted functionality by converting immediate photo deletion to soft delete with recovery window.
Output: Modified photoService with soft delete methods, Cloud Function for scheduled permanent deletion.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23.1-recently-deleted/23.1-CONTEXT.md
@.planning/phases/23-photo-deletion-archiving/23-01-SUMMARY.md
@.planning/phases/19-delete-account-fallback/19-01-SUMMARY.md

**Key files:**
@src/services/firebase/photoService.js
@functions/index.js

**Pattern reference:** Phase 19 established scheduled deletion pattern with:

- `scheduledForDeletionAt` timestamp field (30 days from now)
- `deletionScheduledAt` timestamp for when action was scheduled
- Daily cron job at 3 AM UTC for processing
- FieldValue.delete() to clear fields when canceling

**Current photo deletion flow:**

- `triagePhoto(photoId, 'delete')` - Immediately deletes (Darkroom context)
- `deletePhotoCompletely(photoId, userId)` - Cascade delete with albums/comments (PhotoDetailScreen/Album menu)

**Target flow:**

- Both deletion paths set `photoState: 'deleted'` + `scheduledForPermanentDeletionAt`
- `permanentlyDeletePhoto` for bypassing grace period
- `restoreDeletedPhoto` for recovery
- Cloud Function processes expired photos daily
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add soft delete methods to photoService</name>
  <files>src/services/firebase/photoService.js</files>
  <action>
  Modify and add methods for soft delete infrastructure:

1. **Modify `triagePhoto` delete action** (lines ~368-378):
   - Instead of immediately deleting, update the photo document:
     - `photoState: 'deleted'`
     - `status: 'triaged'` (keep consistent with other states)
     - `scheduledForPermanentDeletionAt: Timestamp.fromDate(new Date(Date.now() + 30 * 24 * 60 * 60 * 1000))`
     - `deletionScheduledAt: serverTimestamp()`
   - DO NOT delete from storage or Firestore yet

2. **Add `softDeletePhoto(photoId, userId)`** (new export):
   - For PhotoDetailScreen/Album menu context (not Darkroom)
   - Verify ownership (userId matches photo.userId)
   - Set same fields as triagePhoto delete action
   - Return `{ success: true }` or `{ success: false, error }`

3. **Add `restoreDeletedPhoto(photoId, userId)`** (new export):
   - Verify ownership
   - Verify `photoState === 'deleted'` (can only restore deleted photos)
   - Update: `photoState: 'journal'`, clear `scheduledForPermanentDeletionAt` and `deletionScheduledAt` using FieldValue.delete()
   - Reset `triagedAt: serverTimestamp()` to restart visibility window
   - Return `{ success: true }` or `{ success: false, error }`

4. **Add `getDeletedPhotos(userId)`** (new export):
   - Query photos where `userId === userId` AND `photoState === 'deleted'`
   - Order by `deletionScheduledAt desc` (most recently deleted first)
   - Return array of photo objects with id, imageURL, scheduledForPermanentDeletionAt, deletionScheduledAt

5. **Add `permanentlyDeletePhoto(photoId, userId)`** (new export):
   - For immediate deletion bypassing grace period
   - Verify ownership
   - Use existing `deletePhotoCompletely` cascade logic (albums, comments, storage, document)
   - Can delete photos in ANY photoState (journal, archive, or deleted)

6. **Rename/update `deletePhotoCompletely`**:
   - Keep as internal cascade function
   - Called by `permanentlyDeletePhoto` and Cloud Function
   - Remove ownership check since callers verify ownership
     </action>
     <verify>

- npm run lint passes (only pre-existing warnings)
- New exports visible: softDeletePhoto, restoreDeletedPhoto, getDeletedPhotos, permanentlyDeletePhoto
- triagePhoto with 'delete' action no longer immediately deletes (check function body)
  </verify>
  <done>
- triagePhoto delete action sets photoState:'deleted' with scheduledForPermanentDeletionAt
- softDeletePhoto exported and sets same soft delete fields
- restoreDeletedPhoto exported and clears deletion fields
- getDeletedPhotos exported and queries deleted photos
- permanentlyDeletePhoto exported for bypassing grace period
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add scheduled photo deletion Cloud Function</name>
  <files>functions/index.js</files>
  <action>
  Add Cloud Function following Phase 19 pattern:

1. **Add `processScheduledPhotoDeletions`** (after processScheduledDeletions, ~line 1220):

   ```javascript
   /**
    * Process scheduled photo deletions
    * Runs daily at 3:15 AM UTC to permanently delete photos past their 30-day grace period
    * Offset from account deletion (3 AM) to avoid resource contention
    */
   exports.processScheduledPhotoDeletions = functions.pubsub
     .schedule('15 3 * * *') // 3:15 AM UTC daily
     .onRun(async context => {
       const db = admin.firestore();
       const bucket = getStorage().bucket();
       const now = admin.firestore.Timestamp.now();

       logger.info('processScheduledPhotoDeletions: Starting', { checkTime: now.toDate() });

       try {
         // Query photos where scheduledForPermanentDeletionAt has passed
         const photosSnapshot = await db
           .collection('photos')
           .where('photoState', '==', 'deleted')
           .where('scheduledForPermanentDeletionAt', '<=', now)
           .get();

         if (photosSnapshot.empty) {
           logger.info('processScheduledPhotoDeletions: No photos to delete');
           return { processed: 0, deleted: 0, failed: 0 };
         }

         logger.info('processScheduledPhotoDeletions: Found photos', {
           count: photosSnapshot.size,
         });

         let deleted = 0;
         let failed = 0;

         for (const photoDoc of photosSnapshot.docs) {
           const photoId = photoDoc.id;
           const photoData = photoDoc.data();
           const userId = photoData.userId;

           try {
             // Step 1: Remove from user's albums
             const albumsSnapshot = await db
               .collection('albums')
               .where('userId', '==', userId)
               .get();

             for (const albumDoc of albumsSnapshot.docs) {
               const albumData = albumDoc.data();
               if (albumData.photoIds && albumData.photoIds.includes(photoId)) {
                 if (albumData.photoIds.length === 1) {
                   // Last photo - delete album
                   await albumDoc.ref.delete();
                 } else {
                   // Remove photo from album
                   const newPhotoIds = albumData.photoIds.filter(id => id !== photoId);
                   const updateData = { photoIds: newPhotoIds };
                   // Update cover if needed
                   if (albumData.coverPhotoId === photoId && newPhotoIds.length > 0) {
                     updateData.coverPhotoId = newPhotoIds[0];
                   }
                   await albumDoc.ref.update(updateData);
                 }
               }
             }

             // Step 2: Delete comments subcollection
             const commentsSnapshot = await db
               .collection('photos')
               .doc(photoId)
               .collection('comments')
               .get();

             for (const commentDoc of commentsSnapshot.docs) {
               // Delete comment likes subcollection
               const likesSnapshot = await commentDoc.ref.collection('likes').get();
               for (const likeDoc of likesSnapshot.docs) {
                 await likeDoc.ref.delete();
               }
               await commentDoc.ref.delete();
             }

             // Step 3: Delete from Storage
             if (photoData.imageURL) {
               try {
                 const decodedUrl = decodeURIComponent(photoData.imageURL);
                 const pathMatch = decodedUrl.match(/\/o\/(.+?)\?/);
                 if (pathMatch) {
                   await bucket.file(pathMatch[1]).delete();
                 }
               } catch (storageError) {
                 logger.warn('processScheduledPhotoDeletions: Storage delete failed', {
                   photoId,
                   error: storageError.message,
                 });
                 // Continue - file might not exist
               }
             }

             // Step 4: Delete photo document
             await photoDoc.ref.delete();

             logger.debug('processScheduledPhotoDeletions: Photo deleted', { photoId });
             deleted++;
           } catch (photoError) {
             logger.error('processScheduledPhotoDeletions: Failed to delete photo', {
               photoId,
               error: photoError.message,
             });
             failed++;
             // Continue to next photo
           }
         }

         logger.info('processScheduledPhotoDeletions: Completed', {
           processed: photosSnapshot.size,
           deleted,
           failed,
         });

         return { processed: photosSnapshot.size, deleted, failed };
       } catch (error) {
         logger.error('processScheduledPhotoDeletions: Fatal error', { error: error.message });
         return null;
       }
     });
   ```

2. **Firestore composite index** - Add to firestore.indexes.json:
   ```json
   {
     "collectionGroup": "photos",
     "queryScope": "COLLECTION",
     "fields": [
       { "fieldPath": "photoState", "order": "ASCENDING" },
       { "fieldPath": "scheduledForPermanentDeletionAt", "order": "ASCENDING" }
     ]
   }
   ```

Note: The composite index is needed for the `where('photoState', '==', 'deleted').where('scheduledForPermanentDeletionAt', '<=', now)` query.
</action>
<verify>

- functions/index.js has processScheduledPhotoDeletions export
- firestore.indexes.json has composite index for photoState + scheduledForPermanentDeletionAt
- npm run lint in functions/ passes (or only pre-existing warnings)
  </verify>
  <done>
- processScheduledPhotoDeletions Cloud Function created with daily 3:15 AM UTC schedule
- Function queries deleted photos past grace period and cascade deletes (albums, comments, storage, document)
- Composite index added to firestore.indexes.json
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] npm run lint passes (only pre-existing warnings)
- [ ] triagePhoto 'delete' action sets soft delete fields, not immediate delete
- [ ] All new photoService exports work correctly (softDeletePhoto, restoreDeletedPhoto, getDeletedPhotos, permanentlyDeletePhoto)
- [ ] Cloud Function processScheduledPhotoDeletions exists in functions/index.js
- [ ] Composite index added to firestore.indexes.json
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No TypeScript/ESLint errors introduced
- Soft delete infrastructure ready for UI layer (Plan 02)
  </success_criteria>

<output>
After completion, create `.planning/phases/23.1-recently-deleted/23.1-01-SUMMARY.md`
</output>
