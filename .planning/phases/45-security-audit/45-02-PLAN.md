---
phase: 45-security-audit
plan: 02
type: execute
---

<objective>
Fix Cloud Functions access control vulnerabilities — add photo authorization to getSignedPhotoUrl, restrict CORS on destructive functions, and sanitize error messages.

Purpose: Close authorization bypasses in callable functions that allow any authenticated user to generate signed URLs for any photo, and prevent CSRF-style attacks on account deletion endpoints.
Output: Updated functions/index.js with proper access validation, restricted CORS, and safe error messages.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-security-audit/45-CONTEXT.md
@.planning/phases/45-security-audit/45-01-PLAN.md
@functions/index.js

**Constraining decisions:**

- Phase 23: Firestore rules hardened — Cloud Functions use Admin SDK to bypass rules by design
- Storage rules (plan 45-01): Main photos now owner-only read in Storage — getSignedPhotoUrl is the ONLY way non-owners access photos

**Critical findings from security audit:**

1. CRITICAL: getSignedPhotoUrl (line ~1445-1499) generates signed URLs for ANY authenticated user without checking photo ownership or friendship. After plan 45-01 tightens Storage rules to owner-only, this function becomes the sole access path for non-owners — making authorization here essential.
2. MEDIUM-HIGH: deleteUserAccount, scheduleUserAccountDeletion, cancelUserAccountDeletion all set `cors: true` without origin restriction, allowing any website to call these endpoints if user has a valid auth token.
3. MEDIUM: Error messages in deleteUserAccount (line ~1865) expose raw error.message to client, potentially leaking internal details (database paths, service names).
   </context>

<tasks>

<task type="auto">
  <name>Task 1: Add photo access validation to getSignedPhotoUrl</name>
  <files>functions/index.js</files>
  <action>
In the `getSignedPhotoUrl` function, add authorization checks AFTER the existing authentication and photoPath validation, but BEFORE generating the signed URL:

1. **Extract userId from the photo path**: The photoPath format is `photos/{userId}/{filename}`. Parse the path to extract the photo owner's userId.

2. **Check if requester is the photo owner**: If `request.auth.uid === photoOwnerId`, allow access immediately.

3. **If not owner, check friendship**: Query Firestore for an accepted friendship between the requester and photo owner. Use the deterministic friendship ID format: `[lowerUserId]_[higherUserId]`. Check that the friendship document exists and has `status === 'accepted'`.

4. **If not owner and not friends**: Throw `HttpsError('permission-denied', 'You do not have access to this photo')`.

5. **Add logging**: Log the access check result (allowed/denied, reason) at debug level.

Implementation pattern:

```javascript
// After existing auth + photoPath validation
const pathParts = photoPath.split('/');
if (pathParts.length < 2 || pathParts[0] !== 'photos') {
  throw new HttpsError('invalid-argument', 'Invalid photo path');
}
const photoOwnerId = pathParts[1];

// Owner can always access
if (userId !== photoOwnerId) {
  // Check friendship
  const id1 = userId < photoOwnerId ? userId : photoOwnerId;
  const id2 = userId < photoOwnerId ? photoOwnerId : userId;
  const friendshipDoc = await admin
    .firestore()
    .collection('friendships')
    .doc(`${id1}_${id2}`)
    .get();

  if (!friendshipDoc.exists || friendshipDoc.data().status !== 'accepted') {
    logger.warn('getSignedPhotoUrl: Access denied', { userId, photoOwnerId });
    throw new HttpsError('permission-denied', 'You do not have access to this photo');
  }
}
```

Also handle profile-photos path: if photoPath starts with `profile-photos/`, allow any authenticated user (profile photos are semi-public within the app).

**What to avoid:** Do NOT use `get()` on the photos Firestore collection — the photo document may not include Storage path info needed for reverse lookup. Parse the Storage path directly since it contains the userId.
</action>
<verify>Read the updated getSignedPhotoUrl function and verify: auth check exists, path parsing extracts owner, owner bypass works, friendship check queries correct doc, non-friend/non-owner gets permission-denied error, profile-photos path handled separately.</verify>
<done>getSignedPhotoUrl validates that requester is either the photo owner or an accepted friend before generating signed URL. Profile-photo paths allow any authenticated user.</done>
</task>

<task type="auto">
  <name>Task 2: Restrict CORS on destructive functions and sanitize error messages</name>
  <files>functions/index.js</files>
  <action>
**CORS restriction:**

1. Find all `onCall({ cors: true }, ...)` declarations for destructive functions:
   - `deleteUserAccount`
   - `scheduleUserAccountDeletion`
   - `cancelUserAccountDeletion`

2. Remove `cors: true` from these functions — they are called from the React Native app which doesn't need CORS (native HTTP requests aren't subject to CORS). Change to `onCall(async request => ...)` without the cors option object, OR set `cors: false` explicitly.

3. Keep `cors: true` on `getSignedPhotoUrl` and `getMutualFriendSuggestions` if they have it — these are non-destructive read operations.

**Error message sanitization:**

4. Find all `throw new HttpsError(...)` calls in the destructive functions where `error.message` is appended to the user-facing message. Replace with generic messages:
   - `deleteUserAccount` catch block: Change `'Account deletion failed: ' + error.message` to `'Account deletion failed. Please try again later.'`
   - Apply same pattern to `scheduleUserAccountDeletion` and `cancelUserAccountDeletion` if they expose error details.

5. Ensure the FULL error is still logged internally via `logger.error()` BEFORE throwing the sanitized HttpsError. The pattern should be:

```javascript
} catch (error) {
  logger.error('deleteUserAccount: Failed', { userId, error: error.message });
  throw new HttpsError('internal', 'Account deletion failed. Please try again later.');
}
```

**What to avoid:** Do NOT remove the detailed internal logging — we need those for debugging. Only sanitize what's returned TO the client via HttpsError.
</action>
<verify>Search for `cors: true` in functions/index.js to confirm it's removed from all destructive functions. Search for `error.message` in HttpsError throws to confirm no raw errors are returned to clients. Verify logger.error calls still include full error details.</verify>
<done>Destructive Cloud Functions have CORS disabled, all error messages returned to clients are generic (no internal details), internal logging retains full error context.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] getSignedPhotoUrl checks photo ownership or friendship before generating URL
- [ ] getSignedPhotoUrl returns permission-denied for unauthorized requests
- [ ] Profile-photo paths still work for any authenticated user
- [ ] deleteUserAccount has no CORS configuration
- [ ] scheduleUserAccountDeletion has no CORS configuration
- [ ] cancelUserAccountDeletion has no CORS configuration
- [ ] No HttpsError contains raw error.message from catch blocks
- [ ] All logger.error calls still include full error details
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No syntax errors in functions/index.js
- getSignedPhotoUrl enforces authorization before URL generation
- Destructive functions are not callable cross-origin
- Error messages don't leak internal implementation details
  </success_criteria>

<output>
After completion, create `.planning/phases/45-security-audit/45-02-SUMMARY.md`
</output>
