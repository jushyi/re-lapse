---
phase: 45-security-audit
plan: 04
type: execute
---

<objective>
Harden client-side input validation and defense-in-depth — add comment text length limits, cap photo tag count, add album name sanitization, and refine logger patterns.

Purpose: Add client-side validation as defense-in-depth alongside Firestore security rules, prevent oversized payloads from reaching the server, and fix overly broad logger sanitization that redacts legitimate values.
Output: Updated commentService.js, photoService.js, albumService.js, and logger.js with proper validation and sanitization.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-security-audit/45-CONTEXT.md
@.planning/phases/45-security-audit/45-01-PLAN.md
@.planning/phases/45-security-audit/45-02-PLAN.md
@.planning/phases/45-security-audit/45-03-PLAN.md
@src/services/firebase/commentService.js
@src/services/firebase/photoService.js
@src/services/firebase/albumService.js
@src/utils/logger.js
@src/utils/validation.js

**Key context:**

- Firestore rules enforce `request.resource.data.userId == request.auth.uid` on comment create (line 160), so userId spoofing is blocked server-side
- addComment in useComments.js (line 125-127) passes `currentUserId` from auth context — properly sourced
- validation.js already has robust username validation (alphanumeric + underscore, 3-24 chars), photo size/type validation, and sanitizeInput for XSS prevention
- Logger sanitization at line 47 uses `/firebase/gi` which is too broad — matches any value containing "firebase" substring

**Security findings being addressed:**

1. MEDIUM: commentService.addComment() has no text length validation — client could send 100KB+ comments
2. MEDIUM: photoService.updatePhotoTags() accepts unlimited taggedUserIds array — no cap on tags
3. MEDIUM: albumService validates name length but doesn't sanitize content (XSS characters stored)
4. MEDIUM: Logger `/firebase/gi` pattern redacts legitimate log values containing "firebase" substring
   </context>

<tasks>

<task type="auto">
  <name>Task 1: Add input validation to commentService and photoService</name>
  <files>src/services/firebase/commentService.js, src/services/firebase/photoService.js</files>
  <action>
**commentService.js — Add text length validation in addComment:**

1. Add constants at the top of the file:

```javascript
const MAX_COMMENT_LENGTH = 2000;
const MAX_MENTIONS_PER_COMMENT = 10;
```

2. In the addComment function, after the existing `if (!text && !mediaUrl)` check (around line 97), add text length validation:

```javascript
// Validate text length
if (text && text.length > MAX_COMMENT_LENGTH) {
  logger.warn('commentService.addComment: Text exceeds max length', {
    length: text.length,
    max: MAX_COMMENT_LENGTH,
  });
  return { success: false, error: 'Comment text is too long' };
}
```

3. Add mediaUrl validation using the existing `isValidUrl` from validation.js. If mediaUrl is provided, validate it's a proper URL:

```javascript
if (mediaUrl && !isValidUrl(mediaUrl)) {
  logger.warn('commentService.addComment: Invalid media URL');
  return { success: false, error: 'Invalid media URL' };
}
```

Import `isValidUrl` from `../../utils/validation`.

4. Add mediaType enum validation if mediaUrl is provided:

```javascript
const VALID_MEDIA_TYPES = ['image', 'gif'];
if (mediaUrl && mediaType && !VALID_MEDIA_TYPES.includes(mediaType)) {
  logger.warn('commentService.addComment: Invalid media type', { mediaType });
  return { success: false, error: 'Invalid media type' };
}
```

**photoService.js — Cap tagged users in updatePhotoTags:**

5. In updatePhotoTags (line 1079), add validation at the start of the function:

```javascript
const MAX_TAGS_PER_PHOTO = 20;

// Validate taggedUserIds
if (!Array.isArray(taggedUserIds)) {
  logger.warn('PhotoService.updatePhotoTags: taggedUserIds is not an array');
  return { success: false, error: 'Invalid tag data' };
}

// Cap and deduplicate
const uniqueIds = [...new Set(taggedUserIds)].slice(0, MAX_TAGS_PER_PHOTO);

// Validate each ID is a non-empty string
const validIds = uniqueIds.filter(id => typeof id === 'string' && id.length > 0);
```

Use `validIds` instead of `taggedUserIds` for the Firestore update.

**What to avoid:** Do NOT change the function signature of addComment — it currently accepts userId as a parameter and this is called from useComments.js with `currentUserId` from auth context. The Firestore rule enforces matching. Changing the signature would break the hook. Do NOT add validation that duplicates what Firestore rules already enforce (ownership checks) — this is purely for input sanitization and size limits.
</action>
<verify>Read updated commentService.js and confirm: MAX_COMMENT_LENGTH check before Firestore write, mediaUrl validated with isValidUrl, mediaType enum validated. Read updated photoService.js and confirm: taggedUserIds validated as array, deduplicated, capped at MAX_TAGS_PER_PHOTO, each element type-checked.</verify>
<done>Comment text limited to 2000 chars, media URL validated, media type enum-checked, photo tags capped at 20 with deduplication and type validation.</done>
</task>

<task type="auto">
  <name>Task 2: Fix logger sanitization and add album name sanitization</name>
  <files>src/utils/logger.js, src/services/firebase/albumService.js</files>
  <action>
**logger.js — Fix overly broad sanitization pattern:**

1. Find the sensitive value patterns array (around line 46-55). The current `/firebase/gi` pattern matches ANY value containing "firebase" as a substring, which redacts legitimate log messages like "Connected to firebase-database" or service names.

2. Replace `/firebase/gi` with more specific patterns that target actual secrets:

```javascript
/firebase[_-]?(api[_-]?key|secret|token|credential|private[_-]?key)/gi,
```

This matches firebase_api_key, firebase-secret, firebaseToken, firebase_credential, firebase_private_key — actual sensitive fields — but NOT generic strings containing "firebase".

3. Also check if there are other patterns in the array that are too broad and could match legitimate values. Common over-broad patterns to tighten:
   - If `/key/gi` exists as a standalone pattern, change to `/^(api[_-]?key|secret[_-]?key|private[_-]?key|access[_-]?key)$/gi` or similar
   - If `/token/gi` exists, change to `/^(auth[_-]?token|access[_-]?token|refresh[_-]?token|bearer[_-]?token|fcm[_-]?token|push[_-]?token)$/gi`

4. Keep the field name checking (which checks object keys like "password", "secret") as-is — those correctly target field names, not values.

**albumService.js — Add name sanitization:**

5. In the albumService's create/update functions, add `sanitizeInput` from validation.js to sanitize album names. After the existing name length validation (around line 58-65), add:

```javascript
import { sanitizeInput } from '../../utils/validation';

// After trimming and length validation:
const sanitizedName = sanitizeInput(trimmedName);
```

Use `sanitizedName` for the Firestore write. This strips any HTML tags or script injection from album names, consistent with how display names and bios are already sanitized.

**What to avoid:** Do NOT remove patterns entirely from the logger — err on the side of redacting too much rather than too little. Just make the patterns more specific so they target actual secrets rather than generic words. Do NOT add sanitization that would prevent emoji in album names — emojis are valid album name characters.
</action>
<verify>Read updated logger.js and confirm: firebase pattern is specific to secrets (not generic substring), no overly broad patterns remain. Read updated albumService.js and confirm: sanitizeInput applied to album names before Firestore write.</verify>
<done>Logger sanitization patterns target actual secrets without redacting legitimate values, album names sanitized against HTML/script injection before storage.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] commentService validates text length before write
- [ ] commentService validates mediaUrl format
- [ ] commentService validates mediaType enum
- [ ] photoService caps taggedUserIds at 20
- [ ] photoService deduplicates and type-checks tag IDs
- [ ] Logger firebase pattern targets secrets specifically
- [ ] No overly broad patterns remain in logger
- [ ] albumService sanitizes names with sanitizeInput
- [ ] All existing tests still pass (if any)
- [ ] `npm run lint` passes
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No linting errors introduced
- Client-side validation prevents oversized/malformed payloads from reaching Firestore
- Logger sanitization is precise — redacts secrets, preserves legitimate values
- Album names sanitized consistently with other user input fields
- Phase 45 Security Audit complete
  </success_criteria>

<output>
After completion, create `.planning/phases/45-security-audit/45-04-SUMMARY.md`
</output>
