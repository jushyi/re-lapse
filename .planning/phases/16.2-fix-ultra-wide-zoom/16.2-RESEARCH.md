# Phase 16.2: Fix 0.5x Ultra-Wide Zoom - Research

**Researched:** 2026-01-21
**Domain:** expo-camera selectedLens prop behavior on iOS
**Confidence:** HIGH

<research_summary>
## Summary

Investigated why the 0.5x ultra-wide zoom (implemented in Phase 15.3) appears broken - showing same view as 1x and not switching cameras properly.

**Root Cause Identified:** The current implementation sets `selectedLens` to `null` for 1x/2x/3x zoom levels, but expo-camera does NOT automatically revert to the default wide-angle camera when `selectedLens` is null. The camera stays on whatever lens was previously selected (ultra-wide), so switching from 0.5x to 1x has no effect.

**Evidence from logs:**
```
LOG  CameraScreen: Zoom level changed {"lens": "Back Ultra Wide Camera", "zoom": 0.5}
LOG  CameraScreen: Zoom level changed {"lens": null, "zoom": 1}
```

The fix is simple: explicitly set `lens: "Back Camera"` for 1x/2x/3x zoom levels instead of `null`.

**Primary recommendation:** Update ZOOM_LEVELS_BASE to include the explicit "Back Camera" lens string for all standard zoom levels, using the actual lens name from `availableLenses` (not null).
</research_summary>

<standard_stack>
## Standard Stack

### Core (Already in Project)
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| expo-camera | 17.0.10 | Camera with lens selection | Already in project, has iOS lens API |

### No Additional Libraries Required
The fix is purely a logic change in how we use the existing API.

### Key API Details
| Property | Type | Notes |
|----------|------|-------|
| `selectedLens` | `string` | Must match exact `localizedName` from device (e.g., "Back Camera", "Back Ultra Wide Camera") |
| `getAvailableLensesAsync()` | `Promise<string[]>` | Returns sorted array of lens names |
| `onAvailableLensesChanged` | `callback` | Fires when camera facing changes |
</standard_stack>

<architecture_patterns>
## Architecture Patterns

### Current (Broken) Pattern
```javascript
// PROBLEM: lens: null does not reset to wide-angle camera
const ZOOM_LEVELS_BASE = [
  { label: '1', value: 1, lens: null, cameraZoom: 0 },    // <-- null doesn't work
  { label: '2', value: 2, lens: null, cameraZoom: 0.17 },
  { label: '3', value: 3, lens: null, cameraZoom: 0.33 },
];
```

### Recommended Fix Pattern
```javascript
// Get the wide-angle lens string from availableLenses
const wideAngleLens = availableLenses.find(lens =>
  lens.toLowerCase() === 'back camera' ||
  lens.toLowerCase().includes('wide angle')
);

// Use explicit lens names for ALL zoom levels
const zoomLevels = useMemo(() => {
  const baseLevels = [
    { label: '1', value: 1, lens: wideAngleLens, cameraZoom: 0 },
    { label: '2', value: 2, lens: wideAngleLens, cameraZoom: 0.17 },
    { label: '3', value: 3, lens: wideAngleLens, cameraZoom: 0.33 },
  ];

  if (Platform.OS === 'ios' && hasUltraWide && facing === 'back') {
    const ultraWideLens = availableLenses.find(lens =>
      lens.toLowerCase().includes('ultra wide')
    );
    return [
      { label: '0.5', value: 0.5, lens: ultraWideLens, cameraZoom: 0 },
      ...baseLevels,
    ];
  }
  return baseLevels;
}, [hasUltraWide, facing, availableLenses, wideAngleLens]);
```

### Pattern: Always Use Explicit Lens Strings
**What:** Never use `null` for selectedLens when switching between lenses
**Why:** expo-camera's iOS implementation does NOT reset to default when selectedLens is null
**When:** Any time you want to switch between physical lenses

### How expo-camera Matches Lenses
The iOS implementation uses `localizedName` (NOT `deviceType`) to match:

```swift
// From CameraSessionManager.swift
let selectedDevice = lenses.first {
  $0.localizedName == delegate.selectedLens
}
```

This means you MUST pass the exact string returned by `getAvailableLensesAsync()`.

### Available Lens Names (from user's device logs)
```json
[
  "Back Camera",              // Standard wide-angle (1x baseline)
  "Back Dual Camera",         // Virtual camera combining wide + telephoto
  "Back Dual Wide Camera",    // Virtual camera combining ultra-wide + wide
  "Back LiDAR Depth Camera",  // Depth sensor
  "Back Telephoto Camera",    // 2-3x optical zoom
  "Back Triple Camera",       // Virtual camera with all three
  "Back Ultra Wide Camera"    // 0.5x ultra-wide lens
]
```

### Anti-Patterns to Avoid
- **Using null for selectedLens:** Camera stays on previous lens, doesn't reset
- **Hardcoding lens names:** Use values from `availableLenses` array
- **Assuming "Back Camera" always exists:** Check `availableLenses` first
</architecture_patterns>

<dont_hand_roll>
## Don't Hand-Roll

| Problem | Don't Do | Do Instead | Why |
|---------|----------|------------|-----|
| Resetting to wide-angle | Set `selectedLens: null` | Set `selectedLens: "Back Camera"` | null doesn't trigger lens switch |
| Finding lens names | Hardcode strings | Use `availableLenses` array | Localizations may vary |
| Detecting ultra-wide | Check device model | Check `availableLenses` for "ultra wide" | Device detection is fragile |

**Key insight:** expo-camera's selectedLens implementation is a simple string match against `localizedName`. There is NO "reset to default" behavior when you pass null - you must explicitly specify every lens change.
</dont_hand_roll>

<common_pitfalls>
## Common Pitfalls

### Pitfall 1: Setting selectedLens to null (THE BUG)
**What goes wrong:** Camera stays on ultra-wide even when user selects 1x
**Why it happens:** expo-camera doesn't reset lens on null - it just keeps current lens
**How to avoid:** Always pass explicit lens name from availableLenses
**Warning signs:** View doesn't change when switching zoom levels
**Evidence:** User's logs show `{"lens": null, "zoom": 1}` has no effect

### Pitfall 2: Not Waiting for availableLenses
**What goes wrong:** wideAngleLens is undefined on first render
**Why it happens:** `onAvailableLensesChanged` is async
**How to avoid:** Default to null lens until availableLenses is populated, then rebuild zoom levels
**Warning signs:** First zoom level switch doesn't work

### Pitfall 3: Wrong String Case/Format
**What goes wrong:** Lens doesn't match, falls back to default
**Why it happens:** String comparison is case-sensitive
**How to avoid:** Use exact string from availableLenses, case-preserving match
**Warning signs:** Lens selection silently fails

### Pitfall 4: Front Camera Has Different Lenses
**What goes wrong:** Trying to use "Back Camera" string on front camera
**Why it happens:** Front camera has different localizedNames
**How to avoid:** Re-check availableLenses when facing changes, use appropriate names
**Warning signs:** Camera crashes or freezes on switch
</common_pitfalls>

<code_examples>
## Code Examples

### Fix: Explicit Wide-Angle Lens for Base Zoom Levels
```javascript
// Source: Derived from expo-camera iOS implementation analysis

// Get wide-angle lens string (typically "Back Camera")
const wideAngleLens = useMemo(() => {
  if (Platform.OS !== 'ios' || facing !== 'back' || availableLenses.length === 0) {
    return null;
  }
  // Look for standard wide-angle camera
  return availableLenses.find(lens =>
    lens.toLowerCase() === 'back camera'
  ) || null;
}, [availableLenses, facing]);

// Build zoom levels with EXPLICIT lens strings
const zoomLevels = useMemo(() => {
  // Build base levels with explicit wide-angle lens
  const baseLevels = [
    { label: '1', value: 1, lens: wideAngleLens, cameraZoom: 0 },
    { label: '2', value: 2, lens: wideAngleLens, cameraZoom: 0.17 },
    { label: '3', value: 3, lens: wideAngleLens, cameraZoom: 0.33 },
  ];

  // Add 0.5x only on iOS with ultra-wide support
  if (Platform.OS === 'ios' && hasUltraWide && facing === 'back') {
    const ultraWideLens = availableLenses.find(lens =>
      lens.toLowerCase().includes('ultra wide')
    );
    return [
      { label: '0.5', value: 0.5, lens: ultraWideLens, cameraZoom: 0 },
      ...baseLevels,
    ];
  }
  return baseLevels;
}, [hasUltraWide, facing, availableLenses, wideAngleLens]);
```

### handleZoomChange - No Changes Needed
```javascript
// Current implementation is fine - just needs correct lens values
const handleZoomChange = (zoomLevel) => {
  if (zoomLevel.value !== zoom.value) {
    lightImpact();
    setZoom(zoomLevel);
    if (Platform.OS === 'ios') {
      setSelectedLens(zoomLevel.lens || null); // This works IF lens is set correctly
    }
  }
};
```

### Debugging: Log Lens Switches
```javascript
// Add this to verify lens switching is working
useEffect(() => {
  logger.info('CameraScreen: selectedLens changed', { selectedLens });
}, [selectedLens]);
```
</code_examples>

<sota_updates>
## State of the Art (2025-2026)

| Old Understanding | Actual Behavior | Impact |
|-------------------|-----------------|--------|
| `selectedLens: null` resets to default | null keeps current lens | Must explicitly set all lens changes |
| Can use deviceType strings | Uses localizedName only | Must match exact string from availableLenses |
| Lens selection is automatic | Manual lens switching | Developer must handle all state |

**Key discovery:** expo-camera's selectedLens is a direct pass-through to iOS's AVCaptureDevice matching by `localizedName`. There is no abstraction or default behavior - you must always specify the exact lens string.
</sota_updates>

<open_questions>
## Open Questions

1. **Localization concerns**
   - What we know: Lens names like "Back Camera" may vary by device language
   - What's unclear: Whether English names work on non-English devices
   - Recommendation: Test on non-English device, may need to match by pattern not exact string

2. **Virtual cameras (Dual/Triple)**
   - What we know: Device returns virtual cameras like "Back Triple Camera"
   - What's unclear: How zoom behaves with virtual camera selected
   - Recommendation: Stick with physical cameras ("Back Camera", "Back Ultra Wide Camera") for predictable behavior
</open_questions>

<sources>
## Sources

### Primary (HIGH confidence)
- [Expo Camera Documentation](https://docs.expo.dev/versions/latest/sdk/camera/) - selectedLens prop, getAvailableLensesAsync API
- [expo-camera CameraSessionManager.swift](https://github.com/expo/expo/blob/main/packages/expo-camera/ios/Current/CameraSessionManager.swift) - Confirmed uses `localizedName` matching
- User's device logs - Confirmed actual lens names and behavior

### Secondary (MEDIUM confidence)
- [PR #36233: iOS Camera Lens Selection](https://github.com/expo/expo/pull/36233) - Implementation details
- [Apple AVCaptureDevice.localizedName](https://developer.apple.com/documentation/avfoundation/avcapturedevice/localizedname) - iOS API documentation

### Evidence From Logs
```
LOG  CameraScreen: onAvailableLensesChanged fired {
  "lenses": ["Back Camera", "Back Dual Camera", "Back Dual Wide Camera",
             "Back LiDAR Depth Camera", "Back Telephoto Camera",
             "Back Triple Camera", "Back Ultra Wide Camera"]
}
LOG  CameraScreen: Zoom level changed {"lens": "Back Ultra Wide Camera", "zoom": 0.5}  // Works
LOG  CameraScreen: Zoom level changed {"lens": null, "zoom": 1}  // BUG: null doesn't switch
```
</sources>

<metadata>
## Metadata

**Research scope:**
- Core technology: expo-camera selectedLens behavior
- Root cause: null lens value doesn't reset camera
- Fix complexity: Low (change constants)

**Confidence breakdown:**
- Root cause: HIGH - Confirmed in logs and iOS source code
- Fix approach: HIGH - Straightforward constant change
- Edge cases: MEDIUM - May need localization testing

**Research date:** 2026-01-21
**Valid until:** 2026-02-21 (30 days - behavior unlikely to change)
</metadata>

---

*Phase: 16.2-fix-ultra-wide-zoom*
*Research completed: 2026-01-21*
*Ready for planning: yes*
