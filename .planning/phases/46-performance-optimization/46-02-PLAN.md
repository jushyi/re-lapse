---
phase: 46-performance-optimization
plan: 02
type: execute
---

<objective>
Add missing Firestore composite indexes, apply query limits to all unbounded queries, and optimize read patterns (batch user fetching, count aggregation).

Purpose: Prevent silent query failures from missing indexes, cap all query result sizes for predictable performance, and eliminate N+1 user data reads and unnecessary document downloads for count operations.
Output: Updated firestore.indexes.json, all service queries bounded with limits, optimized user read batching, count() aggregation for photo counts.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/46-performance-optimization/46-RESEARCH.md
@firestore.indexes.json
@src/services/firebase/feedService.js
@src/services/firebase/photoService.js
@src/services/firebase/albumService.js
@src/services/firebase/blockService.js
@src/services/firebase/notificationService.js
@src/services/firebase/userService.js

**Research patterns to follow:**

- RESEARCH.md indexes section: 5 new composite indexes + 12 field exemptions
- RESEARCH.md Pattern 2: User Data Denormalization is OUT OF SCOPE (architecture change)
- RESEARCH.md code example: Firestore count() instead of getDocs().size
- RESEARCH.md anti-pattern: N+1 reads — batch with Promise.all + deduplication

**Issues being addressed:**

- CRIT-5: 5-6 missing composite indexes
- MED-5: getDevelopingPhotoCount uses getDocs instead of count()
- CRIT-4 (partial): N+1 user data reads — batch user fetching (NOT denormalization)
- All unbounded queries across service files
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Update firestore.indexes.json and add .limit() to all unbounded queries</name>
  <files>firestore.indexes.json, src/services/firebase/photoService.js, src/services/firebase/albumService.js, src/services/firebase/blockService.js, src/services/firebase/notificationService.js, src/services/firebase/userService.js, src/services/firebase/friendshipService.js</files>
  <action>
**Indexes:** Replace firestore.indexes.json with the complete recommended configuration from RESEARCH.md `<indexes>` section. This adds 5 new composite indexes and 12 field exemptions for never-queried fields (reactions map, imageURL, visibility, reactionCount, commentCount, revealedAt, taggedUserIds, taggedAt, notification body/title/data/senderProfilePhotoURL).

**Query limits:** Add appropriate .limit() to ALL unbounded Firestore queries:

- photoService.js getUserPhotos: add `.limit(100)` — user's photo library, paginate if needed
- photoService.js getFeedStats: consider if these 3 queries can use count() instead (addressed in Task 2)
- albumService.js getUserAlbums: add `.limit(50)` — safety bound on album count
- blockService.js getBlockedByUserIds: add `.limit(500)` — practical upper bound
- blockService.js getBlockedUserIds: add `.limit(500)` — practical upper bound
- notificationService.js markNotificationsAsRead: add `.limit(500)` per batch, loop until none remain
- userService.js checkUsernameAvailability: add `.limit(1)` — only need existence check
- friendshipService.js subscribeFriendships: add `.limit(500)` — practical bound on friend count

For each, use the smallest reasonable limit that doesn't break functionality. Add comments explaining the limit value chosen.

Also parallelize sequential reads in blockService.js getBlockedUsersWithProfiles — change the `for` loop to `Promise.all(blockedUserIds.map(...))`.
</action>
<verify>
Grep all service files for Firestore query patterns and confirm:

- Every `getDocs()` or `onSnapshot()` query has a `.limit()` clause
- firestore.indexes.json has 8 composite indexes (3 existing + 5 new) and 12 field exemptions
- blockService uses Promise.all instead of sequential loop
  </verify>
  <done>All Firestore queries bounded with limits. 5 new composite indexes defined. 12 field exemptions added. Sequential reads parallelized.</done>
  </task>

<task type="auto">
  <name>Task 2: Batch user reads and replace getDocs with count()</name>
  <files>src/services/firebase/feedService.js, src/services/firebase/photoService.js</files>
  <action>
**Batch user reads in feedService:**
In getFeedPhotos (after the `in` operator refactor from Plan 46-01), the function may still fetch user data individually for each photo result. Optimize this:

1. After fetching photo results, collect all unique `userId` values into a Set
2. Batch fetch user documents with `Promise.all(uniqueUserIds.map(id => getDoc(doc(db, 'users', id))))`
3. Create a lookup Map: `userId → userData`
4. Attach user data to photos from the lookup map instead of individual reads

Apply the same pattern to any other function in feedService that reads user data per-photo (getFriendStoriesData already uses Promise.all — verify and skip if already optimized).

**Count aggregation in photoService:**
Replace getDevelopingPhotoCount (which uses getDocs().size to count developing photos) with Firestore count() aggregation:

```javascript
import { getCountFromServer } from 'firebase/firestore';

const snapshot = await getCountFromServer(
  query(
    collection(db, 'photos'),
    where('userId', '==', userId),
    where('status', '==', 'developing')
  )
);
return snapshot.data().count;
```

This downloads zero documents — just the count number. Saves N reads per count call.

Also check if getFeedStats (3 queries for journaled/archived/developing counts) can similarly use count(). If so, refactor those too.

NOTE: Verify that `getCountFromServer` is available in the Firebase SDK version this project uses. If not available, keep getDocs but add .limit() as a safety bound.
</action>
<verify>

- Read feedService to confirm user data is batch-fetched with deduplication
- Read photoService to confirm count() aggregation is used
- Verify no N+1 user read pattern remains in feedService
  </verify>
  <done>User reads are batched and deduplicated. Count operations use aggregation queries instead of downloading documents. Feed load reads reduced by ~15 per load.</done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] firestore.indexes.json has 8 composite indexes + 12 field exemptions
- [ ] All service queries have .limit() applied
- [ ] User data reads in feedService are batched with Promise.all + dedup map
- [ ] Photo count uses getCountFromServer (or .limit() fallback)
- [ ] No sequential reads in blockService (uses Promise.all)
- [ ] No N+1 user read patterns remain
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No unbounded Firestore queries in any service file
- User data reads optimized from N individual calls to batch
- Count operations don't download documents
  </success_criteria>

<output>
After completion, create `.planning/phases/46-performance-optimization/46-02-SUMMARY.md`
</output>
