---
phase: 46-performance-optimization
plan: 06
type: execute
---

<objective>
Optimize Cloud Functions cold start time with preferRest initialization, add appropriate memory/timeout configurations, and implement lazy imports for non-universal dependencies.

Purpose: User-facing Cloud Functions (getSignedPhotoUrl, getMutualFriendSuggestions) currently cold start in 4-5 seconds due to gRPC binary loading. preferRest reduces this to 1-2 seconds. Adding .runWith() configs prevents timeouts for long-running deletion functions and right-sizes memory allocation.
Output: Cloud Functions with 50-70% faster cold starts, appropriate resource allocation, and lazy dependency loading.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
~/.claude/get-shit-done/templates/phase-prompt.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/46-performance-optimization/46-RESEARCH.md
@functions/index.js

**Research patterns to follow:**

- RESEARCH.md Pattern 4: Cloud Functions preferRest Initialization
- RESEARCH.md cloud_functions_config: Complete function configuration table
- RESEARCH.md Pitfall 5: Cloud Functions Cold Start (4-5 seconds)
- RESEARCH.md Don't Hand-Roll: preferRest instead of custom caching layer
- RESEARCH.md Open Question 3: preferRest ECONNRESET stability — monitor after enabling

**Key constraints:**

- preferRest uses REST transport instead of gRPC — eliminates binary loading
- Some functions need higher memory (512MB) for batch operations
- Long-running deletion functions need 300s timeout (default is 60s)
- minInstances costs ~$6/month per warm instance — only for user-facing functions
- Gen 1 functions use .runWith(), Gen 2 (onCall) use options object in function definition
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Enable preferRest and add .runWith() configurations</name>
  <files>functions/index.js</files>
  <action>
**Enable preferRest:**
Replace the current `admin.initializeApp()` (line ~22) with the preferRest initialization pattern:

```javascript
const { initializeApp, getApps, getApp } = require('firebase-admin/app');
const { initializeFirestore } = require('firebase-admin/firestore');

const app = getApps().length > 0 ? getApp() : initializeApp();
const db = initializeFirestore(app, { preferRest: true });
```

Then update any `admin.firestore()` calls throughout the file to use the `db` variable instead. Search for all occurrences of `admin.firestore()` and replace with `db`.

**Add .runWith() to Gen 1 functions:**
Apply memory and timeout configurations per the research table. For Gen 1 functions (pubsub, firestore triggers), add `.runWith()`:

- `processDarkroomReveals`: `.runWith({ memory: '512MB', timeoutSeconds: 120 })`
- `checkPushReceipts`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendPhotoRevealNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendFriendRequestNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendFriendAcceptedNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendStoryNotification`: `.runWith({ memory: '512MB', timeoutSeconds: 120 })` (sends to multiple recipients)
- `sendReactionNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendTaggedPhotoNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendCommentNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 60 })`
- `sendDeletionReminderNotification`: `.runWith({ memory: '256MB', timeoutSeconds: 300 })`
- `processScheduledDeletions`: `.runWith({ memory: '512MB', timeoutSeconds: 300 })`
- `processScheduledPhotoDeletions`: `.runWith({ memory: '512MB', timeoutSeconds: 300 })`

**For Gen 2 functions (onCall):**
onCall functions defined with `onCall()` from `firebase-functions/v2/https` accept an options object as the first argument:

```javascript
exports.getSignedPhotoUrl = onCall({ memory: '256MiB', timeoutSeconds: 30 }, async (request) => { ... });
exports.getMutualFriendSuggestions = onCall({ memory: '512MiB', timeoutSeconds: 120 }, async (request) => { ... });
exports.deleteUserAccount = onCall({ memory: '512MiB', timeoutSeconds: 300 }, async (request) => { ... });
exports.scheduleUserAccountDeletion = onCall({ memory: '256MiB', timeoutSeconds: 30 }, async (request) => { ... });
exports.cancelUserAccountDeletion = onCall({ memory: '256MiB', timeoutSeconds: 30 }, async (request) => { ... });
```

Note: Gen 2 uses 'MiB' (mebibytes), Gen 1 uses 'MB' (megabytes). Use the correct unit for each.

Do NOT add minInstances yet — that costs money and should be a deliberate decision after testing.
</action>
<verify>
Read functions/index.js and confirm:

- `preferRest: true` is set on Firestore initialization
- No remaining `admin.firestore()` calls (all replaced with `db`)
- All Gen 1 functions have `.runWith()` with appropriate memory/timeout
- All Gen 2 functions have options objects with memory/timeout
  </verify>
  <done>Cloud Functions use preferRest for 50-70% faster cold starts. All functions have appropriate memory and timeout configurations.</done>
  </task>

<task type="auto">
  <name>Task 2: Implement lazy imports for storage and notification modules</name>
  <files>functions/index.js</files>
  <action>
Move non-universal imports from top-level to inside the functions that use them. This reduces cold start time for functions that don't need these modules.

**Lazy-load `firebase-admin/storage`:**
Currently imported at top level but only used in 4 functions. Move the require inside those functions:

Remove from top-level:

```javascript
// const { getStorage } = require('firebase-admin/storage');  // REMOVE
```

Add inside each function that uses it:

```javascript
// Inside getSignedPhotoUrl, deleteUserAccount, processScheduledDeletions, processScheduledPhotoDeletions:
const { getStorage } = require('firebase-admin/storage');
```

Node.js caches `require()` calls — the second require returns the cached module instantly. So lazy loading only affects the FIRST cold start for that specific function, with zero overhead on subsequent calls.

**Lazy-load notification modules:**
The `notifications/sender` and `notifications/receipts` modules are only used in notification functions and checkPushReceipts. Move imports inside those functions:

Remove from top-level:

```javascript
// const { sendPushNotification, expo } = require('./notifications/sender');  // REMOVE
// const { getPendingReceipts, ... } = require('./notifications/receipts');  // REMOVE
```

Add inside each notification function:

```javascript
// Inside send*Notification functions:
const { sendPushNotification } = require('./notifications/sender');

// Inside checkPushReceipts:
const {
  getPendingReceipts,
  deletePendingReceipt,
  removeInvalidToken,
} = require('./notifications/receipts');
```

**Keep at top level** (used by most functions):

- `firebase-functions` — core runtime
- `firebase-admin` — core SDK
- `firebase-admin/app` — app initialization
- `firebase-admin/firestore` — database (used by almost all functions)
- `./logger` — used everywhere
- `./validation` — used in multiple functions (could be lazy-loaded but low impact)

This ensures non-notification functions (getSignedPhotoUrl, getMutualFriendSuggestions, deletion functions) don't load the Expo push SDK on cold start.
</action>
<verify>
Read functions/index.js top-level imports and confirm:

- `getStorage` is NOT imported at top level
- `sendPushNotification` and notification modules are NOT imported at top level
- Each function that uses these modules has a local require() call
- Core modules (admin, functions, logger) remain at top level
  </verify>
  <done>Storage and notification modules lazily loaded. Non-notification functions no longer load Expo SDK on cold start. Each function loads only its required dependencies.</done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] preferRest enabled on Firestore initialization
- [ ] All `admin.firestore()` calls replaced with `db`
- [ ] All functions have .runWith() or options with memory/timeout
- [ ] Storage module lazily loaded in 4 functions
- [ ] Notification modules lazily loaded in notification functions
- [ ] Core modules remain at top level
- [ ] No syntax errors (verify with `node -c functions/index.js` or equivalent)
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Cold starts reduced 50-70% via preferRest
- Functions have appropriate resource limits
- Non-notification functions don't load notification dependencies
  </success_criteria>

<output>
After completion, create `.planning/phases/46-performance-optimization/46-06-SUMMARY.md`
</output>
