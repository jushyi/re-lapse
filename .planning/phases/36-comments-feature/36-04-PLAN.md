---
phase: 36-comments-feature
plan: 04
type: execute
---

<objective>
Implement comment likes and delete functionality.

Purpose: Enable users to like comments (heart toggle) and delete their own comments (or any comment if photo owner).
Output: Fully functional like/unlike on comments, delete with confirmation, proper UI feedback.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/36-comments-feature/36-CONTEXT.md
@.planning/phases/36-comments-feature/36-RESEARCH.md

**Key source files:**
@src/services/firebase/commentService.js
@src/components/comments/CommentRow.js
@src/hooks/useComments.js

**From RESEARCH.md - Likes pattern:**

- Separate subcollection: photos/{photoId}/comments/{commentId}/likes/{likeId}
- Deterministic likeId: `${photoId}_${commentId}_${userId}` for lookup without query
- Optimistic UI updates with revert on failure
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add comment likes service and UI</name>
  <files>src/services/firebase/commentService.js, src/components/comments/CommentRow.js, src/hooks/useComments.js</files>
  <action>
**Add to commentService.js:**

```javascript
// Check if user liked a comment (deterministic ID lookup)
export const hasUserLikedComment = async (photoId, commentId, userId) => {
  const likeId = `${photoId}_${commentId}_${userId}`;
  const likeRef = doc(db, 'photos', photoId, 'comments', commentId, 'likes', likeId);
  const likeDoc = await getDoc(likeRef);
  return likeDoc.exists();
};

// Toggle like on comment
export const toggleCommentLike = async (photoId, commentId, userId) => {
  const likeId = `${photoId}_${commentId}_${userId}`;
  const likeRef = doc(db, 'photos', photoId, 'comments', commentId, 'likes', likeId);
  const commentRef = doc(db, 'photos', photoId, 'comments', commentId);

  try {
    const likeDoc = await getDoc(likeRef);

    if (likeDoc.exists()) {
      // Unlike: delete like doc, decrement count
      await deleteDoc(likeRef);
      await updateDoc(commentRef, { likeCount: increment(-1) });
      return { success: true, liked: false };
    } else {
      // Like: create like doc, increment count
      await setDoc(likeRef, {
        userId,
        createdAt: serverTimestamp(),
      });
      await updateDoc(commentRef, { likeCount: increment(1) });
      return { success: true, liked: true };
    }
  } catch (error) {
    logger.error('CommentService.toggleCommentLike: Failed', { error: error.message });
    return { success: false, error: error.message };
  }
};

// Get user's likes for multiple comments (batch check)
export const getUserLikesForComments = async (photoId, commentIds, userId) => {
  const likes = {};
  await Promise.all(
    commentIds.map(async commentId => {
      likes[commentId] = await hasUserLikedComment(photoId, commentId, userId);
    })
  );
  return likes;
};
```

**Update useComments.js:**

- Track userLikes state: `{ [commentId]: boolean }`
- On load, call getUserLikesForComments for visible comments
- Add `toggleLike(commentId)` function with optimistic update:

  ```javascript
  const toggleLike = async commentId => {
    // Optimistic update
    setUserLikes(prev => ({ ...prev, [commentId]: !prev[commentId] }));
    setComments(prev =>
      prev.map(c =>
        c.id === commentId ? { ...c, likeCount: c.likeCount + (userLikes[commentId] ? -1 : 1) } : c
      )
    );

    // Sync to Firestore
    const result = await commentService.toggleCommentLike(photoId, commentId, currentUserId);
    if (!result.success) {
      // Revert on failure
      setUserLikes(prev => ({ ...prev, [commentId]: !prev[commentId] }));
      setComments(prev =>
        prev.map(c =>
          c.id === commentId
            ? { ...c, likeCount: c.likeCount + (userLikes[commentId] ? 1 : -1) }
            : c
        )
      );
    }
  };
  ```

**Update CommentRow.js:**

- Heart icon: outline (heart-outline) when not liked, filled (heart) when liked
- Use Ionicons from @expo/vector-icons
- onPress calls onLike(comment.id)
- Show likeCount next to heart if > 0
- Add haptic feedback on like (expo-haptics light impact)

**Heart icon colors:**

- Liked: red fill (#FF3B30 or similar)
- Not liked: gray outline
  </action>
  <verify>
  Open CommentsBottomSheet, tap heart on a comment, verify it fills red and count increments. Tap again, verify it unfills and count decrements.
  </verify>
  <done>
- toggleCommentLike added to commentService with optimistic pattern
- hasUserLikedComment and getUserLikesForComments helper functions
- useComments tracks userLikes state and provides toggleLike function
- CommentRow heart icon toggles filled/outline with haptic feedback
- Like count displays next to heart
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add delete comment functionality</name>
  <files>src/services/firebase/commentService.js, src/components/comments/CommentRow.js, src/hooks/useComments.js</files>
  <action>
**Update CommentRow.js for delete:**

**Delete trigger options (choose one):**
Option A: Long-press to delete (simple, Instagram-style)
Option B: Swipe-to-delete (more complex, native feel)
Option C: Ellipsis menu with "Delete" option

**Implement Option A (long-press):**

- Wrap comment content in TouchableOpacity with onLongPress
- Show Alert.alert with "Delete Comment" title, "Are you sure?" message
- Options: "Cancel" (cancel style), "Delete" (destructive style)
- Only show delete option if `canDelete` prop is true

**canDelete logic (in CommentsBottomSheet/useComments):**

```javascript
const canDelete = comment => {
  return comment.userId === currentUserId || photoOwnerId === currentUserId;
};
```

**deleteComment in commentService.js** (already defined in Plan 01):

- Verify the delete flow works correctly
- Handle cascade delete of replies (if comment has parentId=null and has replies)

**Update useComments.js:**

- Add `deleteComment(commentId)` function
- Optimistic removal from comments array
- Call commentService.deleteComment
- If has replies, delete those too (or just hide parent, show "[deleted]")

**For replies cascade:**

- Query comments where parentId == commentId
- Delete each reply first
- Then delete the parent comment
- Update commentCount by total deleted count

**UI feedback:**

- Show brief loading indicator during delete
- Haptic feedback on successful delete (success notification)
- If error, show Alert with error message
  </action>
  <verify>
  Long-press on own comment, verify delete confirmation appears. Confirm delete, verify comment removed. Try to delete someone else's comment as non-owner, verify option doesn't appear.
  </verify>
  <done>
- Long-press delete with confirmation Alert
- canDelete properly checks comment author OR photo owner
- Cascade delete for parent comments with replies
- Optimistic UI removal with revert on failure
- commentCount properly decremented
- Haptic feedback on delete
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Heart icon toggles between outline/filled on tap
- [ ] Like count updates immediately (optimistic)
- [ ] Long-press shows delete confirmation (only when allowed)
- [ ] Delete removes comment and updates count
- [ ] Photo owner can delete any comment
- [ ] Haptic feedback on like and delete
</verification>

<success_criteria>

- Like toggle works with optimistic UI and Firestore sync
- Heart icon red when liked, gray when not
- Like count displays correctly
- Delete confirmation prevents accidental deletion
- Photo owner can moderate comments (delete any)
- Users can only delete their own comments (unless photo owner)
- Cascade delete handles replies to deleted parent
  </success_criteria>

<output>
After completion, create `.planning/phases/36-comments-feature/36-04-SUMMARY.md`
</output>
