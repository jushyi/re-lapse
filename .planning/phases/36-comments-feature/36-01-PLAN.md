---
phase: 36-comments-feature
plan: 01
type: execute
---

<objective>
Create the comment service layer with Firestore CRUD operations and security rules.

Purpose: Establish the data foundation for the Instagram-style comments system with subcollection storage, comment counting, and proper access control.
Output: commentService.js with full CRUD operations, updated Firestore security rules, photo documents supporting commentCount.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/36-comments-feature/36-CONTEXT.md
@.planning/phases/36-comments-feature/36-RESEARCH.md

**Key source files:**
@src/services/firebase/feedService.js
@src/services/firebase/friendshipService.js
@firestore.rules

**Established patterns:**

- Services return `{ success, data, error }` objects
- Firestore subcollections for scalable data (photos/{photoId}/comments)
- FieldValue.increment() for atomic count updates
- onSnapshot listeners for real-time updates
- Deterministic IDs where needed (likes subcollection)

**From RESEARCH.md:**

- Parent reference model for threading: `parentId` field (null = top-level, id = reply)
- Likes stored in subcollection: photos/{photoId}/comments/{commentId}/likes/{odId}
- odId format: `${photoId}_${commentId}_${userId}` for deterministic lookup
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create commentService.js with CRUD operations</name>
  <files>src/services/firebase/commentService.js</files>
  <action>
Create commentService.js following established service patterns:

**Data structure for comments subcollection:**

```javascript
photos/{photoId}/comments/{commentId}
{
  userId: string,
  text: string,
  mediaUrl: string | null,
  mediaType: 'image' | 'gif' | null,
  parentId: string | null,  // null = top-level, id = reply
  likeCount: number,
  createdAt: serverTimestamp(),
}
```

**Implement these functions:**

1. `addComment(photoId, userId, text, mediaUrl = null, mediaType = null, parentId = null)`
   - Add comment to subcollection
   - Increment photo's commentCount using FieldValue.increment(1)
   - Return `{ success, commentId }`

2. `deleteComment(photoId, commentId, requestingUserId)`
   - Verify requester is comment author OR photo owner
   - Delete comment (if has replies, delete those too - query by parentId)
   - Decrement photo's commentCount
   - Return `{ success }` or `{ success: false, error }`

3. `getComments(photoId, limitCount = 50)`
   - Query comments ordered by createdAt ASC
   - Join user data (displayName, profilePhotoURL) from users collection
   - Return `{ success, comments }` where comments include user info

4. `subscribeToComments(photoId, callback, limitCount = 50)`
   - Set up onSnapshot listener
   - Return unsubscribe function
   - Callback receives array of comments with user data

5. `getPreviewComments(photoId, photoOwnerId)`
   - Fetch up to 3 top-level comments
   - Prioritize owner's comment first (caption behavior)
   - Then most recent comments
   - Return `{ success, previewComments }` (1-2 items max)

**User data joining pattern:**
For each comment, fetch user profile in parallel using Promise.all(), then merge into comment object. Cache user data if same user appears multiple times.

**Logging:** Follow established logger patterns (debug on entry, info on success, error on failure).
</action>
<verify>
Manual verification:

1. Import commentService in a test file or console
2. Check function exports exist
3. Code follows service pattern (try/catch, returns {success, data/error})
   </verify>
   <done>

- commentService.js exists with 5 exported functions
- All functions follow `{ success, data, error }` return pattern
- Functions use logger for debug/info/error
- User data joining implemented in getComments and subscribeToComments
- getPreviewComments prioritizes owner comment for caption behavior
  </done>
  </task>

<task type="auto">
  <name>Task 2: Update Firestore security rules and photo schema</name>
  <files>firestore.rules</files>
  <action>
**Add security rules for comments subcollection:**

```
// Inside photos collection rules
match /comments/{commentId} {
  // Anyone authenticated can read comments
  allow read: if request.auth != null;

  // Only authenticated users can create comments
  // Must set own userId, cannot set likeCount > 0
  allow create: if request.auth != null
    && request.resource.data.userId == request.auth.uid
    && request.resource.data.likeCount == 0;

  // Only comment author can update (for editing - future feature)
  allow update: if request.auth != null
    && resource.data.userId == request.auth.uid;

  // Comment author OR photo owner can delete
  allow delete: if request.auth != null
    && (resource.data.userId == request.auth.uid
        || get(/databases/$(database)/documents/photos/$(photoId)).data.userId == request.auth.uid);

  // Likes subcollection
  match /likes/{likeId} {
    allow read: if request.auth != null;

    // Can create like with own userId, deterministic ID
    allow create: if request.auth != null
      && request.resource.data.userId == request.auth.uid;

    // Can delete own likes
    allow delete: if request.auth != null
      && resource.data.userId == request.auth.uid;
  }
}
```

**Update photo document rules:**

- Allow `commentCount` field to be updated by authenticated users (increment only from the original value or same value)
- Use the existing pattern from `reactionCount` updates

**Important:** The commentCount update rule should use `affectedKeys().hasOnly(['commentCount'])` pattern for field-level restrictions when only incrementing.
</action>
<verify>
Deploy and verify rules:

```bash
cd functions && npm run deploy:rules
# Or: firebase deploy --only firestore:rules
```

Rules should deploy without errors.
</verify>
<done>

- Comments subcollection rules added under photos/{photoId}/comments/{commentId}
- Likes subcollection rules added under comments
- Read allowed for authenticated users
- Create requires own userId and likeCount = 0
- Delete allowed for comment author OR photo owner
- commentCount field updates allowed (increment pattern)
- Rules deploy successfully
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] commentService.js exists in src/services/firebase/
- [ ] All 5 functions exported and follow service patterns
- [ ] Firestore rules updated and deployed
- [ ] No TypeScript/ESLint errors in new code
</verification>

<success_criteria>

- commentService.js created with addComment, deleteComment, getComments, subscribeToComments, getPreviewComments
- All functions return { success, data/error } pattern
- Firestore security rules protect comments subcollection
- Photo owner can delete any comment on their photo
- Comment count maintained via FieldValue.increment
- Owner comment prioritized in preview (caption behavior)
  </success_criteria>

<output>
After completion, create `.planning/phases/36-comments-feature/36-01-SUMMARY.md`
</output>
