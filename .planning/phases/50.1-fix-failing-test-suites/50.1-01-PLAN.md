---
phase: 50.1-fix-failing-test-suites
plan: 01
type: execute
---

<objective>
Fix test infrastructure so all 10 failing suites can resolve their mocks correctly.

Purpose: The 5 cloud function suites fail because root jest.config.js sweeps them up with jest-expo instead of their own Node config. The 5 client-side suites fail because the Firestore mock in jest.setup.js doesn't export named modular API functions (limit, Timestamp, startAfter, etc.) and missing service module mocks (blockService, performanceService, albumService). These infrastructure fixes alone will resolve ~47 of the 76 failures.
Output: Updated jest.config.js, package.json test script, jest.setup.js Firestore mock, and new service module mocks.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/50.1-fix-failing-test-suites/50.1-CONTEXT.md

# Key files:

@jest.config.js
@functions/jest.config.js
@package.json
@**tests**/setup/jest.setup.js
@**tests**/**mocks**/@react-native-firebase/firestore.js

# Source files (for understanding required imports):

@src/services/firebase/feedService.js
@src/services/firebase/photoService.js
@src/services/firebase/friendshipService.js
@src/services/firebase/darkroomService.js
@src/services/firebase/performanceService.js
@src/services/firebase/blockService.js
@src/services/firebase/albumService.js

# Prior summaries:

@.planning/phases/49-automated-test-suite/49-01-SUMMARY.md
@.planning/phases/50-cicd-pipeline/50-01-SUMMARY.md

**Constraining decisions:**

- Phase 49: Jest with jest-expo preset for app tests, separate functions/jest.config.js with Node environment for cloud function tests
- Phase 50: PR checks workflow runs `npm test` from root — both app and cloud function tests must pass from root

**Issues being addressed:** None from ISSUES.md — these are mock setup issues, not app bugs.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Cloud Functions test isolation</name>
  <files>jest.config.js, package.json</files>
  <action>
Two changes needed:

1. **jest.config.js** — Add `'<rootDir>/functions/__tests__/'` and `'<rootDir>/functions/'` to `testPathIgnorePatterns` array. This prevents the root Jest runner (jest-expo preset) from picking up cloud function test files that need Node environment and their own mock setup.

2. **package.json** — Update the test scripts to run both test suites:
   - `"test": "jest && cd functions && npx jest"` — runs app tests then cloud function tests sequentially
   - `"test:watch": "jest --watchAll"` — keep as app-only (watch mode for cloud functions not needed)
   - `"test:coverage": "jest --coverage"` — keep as app-only coverage

Do NOT modify functions/jest.config.js — it already works correctly when run from functions/ directory.

**Why sequential (&&) not parallel:** Cloud function tests are fast (~1s) and parallel execution complicates output. The `&&` ensures app tests must pass before running cloud function tests, which matches CI behavior.

**Do NOT use Jest projects feature** — it would require significant config refactoring and the two test suites have completely different presets (jest-expo vs node), setup files, and transform patterns. Sequential execution is simpler and sufficient.
</action>
<verify>
Run `npm test` from project root — all 5 cloud function suites should now pass (they were passing independently via `cd functions && npx jest` already). App test suites will still have failures from mock issues (fixed in Task 2).

Run `cd functions && npx jest` separately to confirm cloud function tests still work independently.
</verify>
<done>
Cloud function tests (smoke, callable, notifications/sender, scheduled, triggers/notifications) pass when run via `npm test` from root. No cloud function test files are matched by root Jest config's testMatch.
</done>
</task>

<task type="auto">
  <name>Task 2: Fix Firestore mock and add missing service mocks</name>
  <files>__tests__/setup/jest.setup.js</files>
  <action>
The `jest.mock('@react-native-firebase/firestore', ...)` factory in jest.setup.js only returns a factory function with `collection` and `doc` on its instance, plus `FieldValue` and `Timestamp` as static properties. But source files use modular named imports:

```javascript
import {
  getFirestore,
  collection,
  doc,
  getDoc,
  getDocs,
  setDoc,
  updateDoc,
  deleteDoc,
  addDoc,
  query,
  where,
  orderBy,
  limit,
  startAfter,
  onSnapshot,
  Timestamp,
  serverTimestamp,
  writeBatch,
  FieldValue,
  getCountFromServer,
  documentId,
  or,
} from '@react-native-firebase/firestore';
```

**Fix the Firestore mock factory** to export all named functions that source files import. Update the `jest.mock('@react-native-firebase/firestore', ...)` block to return an object that includes:

```javascript
// Named modular API exports (what source files import)
getFirestore: jest.fn(() => ({ collection: mockCollection, doc: mockDoc })),
collection: mockCollection,
doc: mockDoc,
getDoc: mockGetDoc,
getDocs: mockGetDocs,
setDoc: mockSetDoc,
updateDoc: mockUpdateDoc,
deleteDoc: mockDeleteDoc,
addDoc: mockAddDoc,
query: mockQuery,
where: mockWhere,
orderBy: mockOrderBy,
limit: mockLimit,
startAfter: mockStartAfter,
onSnapshot: mockOnSnapshot,
serverTimestamp: mockServerTimestamp,
Timestamp: mockTimestamp,
writeBatch: jest.fn(() => ({
  set: jest.fn().mockReturnThis(),
  update: jest.fn().mockReturnThis(),
  delete: jest.fn().mockReturnThis(),
  commit: jest.fn(() => Promise.resolve()),
})),
FieldValue: { serverTimestamp: mockServerTimestamp, increment: jest.fn(n => ({ _increment: n })), arrayUnion: jest.fn((...items) => ({ _arrayUnion: items })), arrayRemove: jest.fn((...items) => ({ _arrayRemove: items })), delete: jest.fn(() => ({ _delete: true })) },
getCountFromServer: jest.fn(() => Promise.resolve({ data: () => ({ count: 0 }) })),
documentId: jest.fn(() => '__documentId__'),
or: mockOr,
and: jest.fn((...queries) => ({})),
```

Also add a `mockStartAfter` variable (already defined but good to confirm) and `mockWriteBatch` mock variable before the jest.mock block, and export them as globals.

Add `getCountFromServer` and `documentId` mock variables before the jest.mock block and export them as globals too.

**Add service module mocks** after the Firestore mock section:

1. **performanceService mock** — The `withTrace` function wraps async operations. In tests, it should pass through:

```javascript
jest.mock('../../src/services/firebase/performanceService', () => ({
  withTrace: jest.fn((name, operation) =>
    operation({ putAttribute: jest.fn(), putMetric: jest.fn() })
  ),
}));
```

Use the path that resolves from `__tests__/setup/jest.setup.js` to `src/services/firebase/performanceService`. Since jest.config.js has moduleNameMapper `@/ -> src/`, try the relative path `../src/services/firebase/performanceService` or use the actual import path the source files use. Check how other service mocks are done in existing test files — if tests use `jest.mock` inline, this global mock may need to use the same path.

Actually, since source files import via relative paths like `'./performanceService'`, and the mock needs to intercept the module as resolved from source files, use the path relative to the project root. The simplest approach: add to jest.setup.js:

```javascript
jest.mock('../../src/services/firebase/performanceService', () => ({ ... }));
```

Wait — jest.setup.js is at `__tests__/setup/jest.setup.js`. The moduleNameMapper maps `@/` to `src/`. But source files use relative imports like `./performanceService`. Jest resolves these relative to the importing file's location. So `jest.mock` needs the module name as it would be resolved. The safest approach is to use the path from root:

For a module at `src/services/firebase/performanceService.js` imported as `./performanceService` from `src/services/firebase/feedService.js`, the resolved path is `<rootDir>/src/services/firebase/performanceService`. In jest.mock, just use the resolvable path. From jest.setup.js at `__tests__/setup/jest.setup.js`, the relative path would be `../../src/services/firebase/performanceService`.

2. **blockService mock** — feedService imports `getBlockedByUserIds`:

```javascript
jest.mock('../../src/services/firebase/blockService', () => ({
  ...jest.requireActual('../../src/services/firebase/blockService'),
  getBlockedByUserIds: jest.fn(() => Promise.resolve({ success: true, blockedByIds: [] })),
}));
```

3. **albumService mock** — photoService imports `getUserAlbums`, `removePhotoFromAlbum`, `deleteAlbum`:

```javascript
jest.mock('../../src/services/firebase/albumService', () => ({
  getUserAlbums: jest.fn(() => Promise.resolve({ success: true, albums: [] })),
  removePhotoFromAlbum: jest.fn(() => Promise.resolve({ success: true })),
  deleteAlbum: jest.fn(() => Promise.resolve({ success: true })),
}));
```

Export the mock functions as globals (e.g., `global.mockGetBlockedByUserIds`, `global.mockWithTrace`) so test files can configure them per-test.

**IMPORTANT: Do NOT use `jest.requireActual` for the service mocks** — these services import from `@react-native-firebase/firestore` themselves, which would cause circular mock issues. Use pure mock factories.

**Also update the `__tests__/__mocks__/@react-native-firebase/firestore.js` file** — This file is currently dead code (overridden by jest.setup.js), but some test files import mock references from it directly. To avoid confusion, either: (a) delete it and have test files use globals from jest.setup.js, or (b) keep it in sync. The safest approach for minimal diff is to leave it as-is since it's not used at runtime.
</action>
<verify>
Run `npm test` — the friendshipService.test.js suite (12 tests) should now pass entirely since all its failures were from missing `limit` export. Other suites will still have some failures from diverged test expectations (fixed in Plan 02).

Verify: `npm test -- __tests__/services/friendshipService.test.js` passes all 63 tests.
</verify>
<done>

- jest.setup.js Firestore mock exports all named modular API functions (getFirestore, collection, doc, getDoc, getDocs, setDoc, updateDoc, deleteDoc, addDoc, query, where, orderBy, limit, startAfter, onSnapshot, Timestamp, serverTimestamp, writeBatch, FieldValue, getCountFromServer, documentId, or, and)
- performanceService, blockService, albumService are mocked globally
- friendshipService.test.js passes all tests (was failing 12, all from missing limit)
- Mock functions exported as globals for per-test configuration
  </done>
  </task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm test -- __tests__/services/friendshipService.test.js` — all 63 tests pass
- [ ] `npm test -- functions/__tests__/smoke.test.js` fails with "no tests found" (excluded from root config)
- [ ] `cd functions && npx jest` — all cloud function tests pass independently
- [ ] `npm test` — cloud function suites no longer appear as failures; total failing suites reduced from 10 to ≤4
</verification>

<success_criteria>

- Cloud function tests excluded from root jest config and pass via sequential npm test script
- Firestore mock exports all modular API functions that source files import
- Service mocks (performanceService, blockService, albumService) registered globally
- friendshipService.test.js passes all tests (12 previously failing → 0 failing)
- Total failing test count reduced from 76 to ≤29
  </success_criteria>

<output>
After completion, create `.planning/phases/50.1-fix-failing-test-suites/50.1-01-SUMMARY.md`
</output>
