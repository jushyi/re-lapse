rules_version = '2';
// Hardened: 2026-01-24 - Phase 23 Security Audit
// Updated: 2026-02-04 - Phase 21 UAT Fix (blocks + reports collections)
// Updated: 2026-02-09 - Phase 45 Security Audit (comment/like access hierarchy, album field protection, remove unused photoViews)
// Changes:
//   - Self-reaction prevention (request.auth.uid != resource.data.userId)
//   - Immutable field protection on photos (userId, capturedAt, imageURL)
//   - Friendship accept restricted to recipient only
//   - Notification update restricted to read/readAt fields only
//   - Blocks collection: blocker/blocked can read, blocker can create/delete
//   - Reports collection: reporter can create, immutable after creation

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper function to check if user owns the resource
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Helper function to check if user is part of a friendship (for existing documents)
    function isFriendshipMember(friendshipData) {
      return isAuthenticated() &&
             (friendshipData.user1Id == request.auth.uid ||
              friendshipData.user2Id == request.auth.uid);
    }

    // Helper function to check if user is part of a friendship by parsing document ID
    // Document ID format: [lowerUserId]_[higherUserId] (deterministic)
    // This allows reading non-existent documents to check if a friendship exists
    function isFriendshipMemberById(friendshipId) {
      let parts = friendshipId.split('_');
      return isAuthenticated() &&
             parts.size() == 2 &&
             (parts[0] == request.auth.uid || parts[1] == request.auth.uid);
    }

    // Helper function to check if users are friends
    function areFriends(userId) {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/friendships/$(generateFriendshipId(request.auth.uid, userId)));
    }

    // Generate deterministic friendship ID
    function generateFriendshipId(uid1, uid2) {
      return uid1 < uid2 ? uid1 + '_' + uid2 : uid2 + '_' + uid1;
    }

    // Helper function to check if only reaction fields are being changed
    // Used for non-owner reaction updates
    function onlyChangesReactionFields() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'reactionCount']);
    }

    // Helper function to check if only comment count is being changed
    // Used for authenticated users updating comment count via increment
    function onlyChangesCommentCount() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount']);
    }

    // Helper function to check if only reaction or comment count fields are being changed
    // Used for non-owner updates (reactions and comment count)
    function onlyChangesReactionOrCommentFields() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['reactions', 'reactionCount', 'commentCount']);
    }

    // Helper function to ensure immutable photo fields are not changed
    // Protects userId, capturedAt from ALL modification
    // Protects imageURL from modification AFTER it's set (allows initial setting from empty)
    function immutablePhotoFieldsUnchanged() {
      let immutableAlways = request.resource.data
        .diff(resource.data)
        .unchangedKeys()
        .hasAll(['userId', 'capturedAt']);
      // imageURL can be changed only if current value is empty (initial set after Storage upload)
      let imageURLProtected =
        resource.data.imageURL == '' ||
        request.resource.data.diff(resource.data).unchangedKeys().hasAny(['imageURL']);
      return immutableAlways && imageURLProtected;
    }

    // =============================================================================
    // USERS COLLECTION
    // =============================================================================
    match /users/{userId} {
      // Anyone authenticated can read any user profile (for friend search, etc.)
      allow read: if isAuthenticated();

      // Users can only create/update/delete their own profile
      allow create: if isOwner(userId) &&
                       request.resource.data.keys().hasAll(['username', 'email', 'createdAt']) &&
                       request.resource.data.username is string &&
                       request.resource.data.email is string;

      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);

      // Viewed Photos subcollection - tracks which story photos user has viewed
      // Data structure: users/{userId}/viewedPhotos/{photoId} { viewedAt: timestamp }
      match /viewedPhotos/{photoId} {
        // Users can only read/write their own viewed photos
        allow read, write: if isOwner(userId);
      }
    }

    // =============================================================================
    // PHOTOS COLLECTION
    // =============================================================================
    match /photos/{photoId} {
      // Read access:
      // - Owner can always read their own photos
      // - Any authenticated user can read journaled photos (client-side filters by friends)
      // - Friends can read each other's photos (for monthly albums, profile views)
      // Note: areFriends() works for bounded queries (e.g., where userId == X)
      allow read: if isOwner(resource.data.userId) ||
                     (isAuthenticated() &&
                      resource.data.photoState == 'journal') ||
                     (isAuthenticated() &&
                      areFriends(resource.data.userId));

      // Create: Only authenticated users can create photos for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'imageURL', 'capturedAt', 'status']) &&
                       request.resource.data.status in ['developing', 'revealed', 'triaged'] &&
                       (request.resource.data.photoState == null ||
                        request.resource.data.photoState in ['journal', 'archive']);

      // Update: Split into owner updates and non-owner updates
      // Case 1: Owner can update their photos (except immutable fields)
      // Case 2: Non-owners can add reactions (prevents self-reactions)
      // Case 3: Any authenticated user can update commentCount (for comment operations)
      allow update: if
        // Owner updates: full access except immutable fields
        (isOwner(resource.data.userId) && immutablePhotoFieldsUnchanged()) ||
        // Non-owner reaction updates: must not be photo owner, can only change reaction fields
        (isAuthenticated() &&
         request.auth.uid != resource.data.userId &&
         onlyChangesReactionFields()) ||
        // Any authenticated user can update comment count (comment add/delete operations)
        (isAuthenticated() && onlyChangesCommentCount());

      // Delete: Only owner can delete their photos
      allow delete: if isOwner(resource.data.userId);

      // =============================================================================
      // COMMENTS SUBCOLLECTION (photos/{photoId}/comments/{commentId})
      // =============================================================================
      match /comments/{commentId} {
        // Comments readable only by users who can access the parent photo
        // (owner, photo is journal state, or user is friends with photo owner)
        allow read: if isAuthenticated() &&
          (get(/databases/$(database)/documents/photos/$(photoId)).data.userId == request.auth.uid ||
           get(/databases/$(database)/documents/photos/$(photoId)).data.photoState == 'journal' ||
           areFriends(get(/databases/$(database)/documents/photos/$(photoId)).data.userId));

        // Only authenticated users can create comments
        // Must set own userId, likeCount must be 0
        allow create: if isAuthenticated() &&
                         request.resource.data.userId == request.auth.uid &&
                         request.resource.data.likeCount == 0 &&
                         request.resource.data.keys().hasAll(['userId', 'text', 'likeCount', 'createdAt']);

        // Comment updates: author can edit text, any authenticated user can update likeCount
        // Case 1: Comment author editing text
        // Case 2: Any user updating likeCount (for like/unlike operations)
        allow update: if isAuthenticated() &&
                         ((resource.data.userId == request.auth.uid &&
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text'])) ||
                          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likeCount']));

        // Comment author OR photo owner can delete
        allow delete: if isAuthenticated() &&
                         (resource.data.userId == request.auth.uid ||
                          get(/databases/$(database)/documents/photos/$(photoId)).data.userId == request.auth.uid);

        // =============================================================================
        // LIKES SUBCOLLECTION (photos/{photoId}/comments/{commentId}/likes/{likeId})
        // =============================================================================
        match /likes/{likeId} {
          // Likes readable only by users who can access the parent photo
          allow read: if isAuthenticated() &&
            (get(/databases/$(database)/documents/photos/$(photoId)).data.userId == request.auth.uid ||
             get(/databases/$(database)/documents/photos/$(photoId)).data.photoState == 'journal' ||
             areFriends(get(/databases/$(database)/documents/photos/$(photoId)).data.userId));

          // Can create like with own userId
          // likeId format: ${photoId}_${commentId}_${userId} (deterministic)
          allow create: if isAuthenticated() &&
                           request.resource.data.userId == request.auth.uid;

          // Can delete own likes
          allow delete: if isAuthenticated() &&
                           resource.data.userId == request.auth.uid;
        }
      }
    }

    // =============================================================================
    // DARKROOMS COLLECTION
    // =============================================================================
    match /darkrooms/{userId} {
      // Users can only read/write their own darkroom
      allow read: if isOwner(userId);

      allow create: if isOwner(userId) &&
                       request.resource.data.userId == userId &&
                       request.resource.data.keys().hasAll(['userId', 'nextRevealAt', 'createdAt']);

      allow update: if isOwner(userId) &&
                       request.resource.data.userId == userId;

      allow delete: if isOwner(userId);
    }

    // =============================================================================
    // FRIENDSHIPS COLLECTION
    // =============================================================================
    match /friendships/{friendshipId} {
      // Read: Users can read friendships they're part of
      // Two cases:
      // 1. Collection queries (where user1Id/user2Id == userId) - use isFriendshipMember
      // 2. Direct document reads (by friendshipId) - use isFriendshipMemberById for non-existent docs
      allow read: if isFriendshipMember(resource.data) || isFriendshipMemberById(friendshipId);

      // Create: Users can create friendships where they are the requester
      allow create: if isAuthenticated() &&
                       request.resource.data.requestedBy == request.auth.uid &&
                       (request.resource.data.user1Id == request.auth.uid ||
                        request.resource.data.user2Id == request.auth.uid) &&
                       request.resource.data.status == 'pending' &&
                       request.resource.data.keys().hasAll(['user1Id', 'user2Id', 'status', 'requestedBy', 'createdAt']);

      // Update: Only recipient (not requester) can accept, and only status/acceptedAt fields can change
      // Security: Prevents requester from accepting their own request
      // Security: Restricts field changes to prevent data tampering
      allow update: if isFriendshipMember(resource.data) &&
                       resource.data.requestedBy != request.auth.uid &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'acceptedAt']);

      // Delete: Users can delete friendships they're part of (unfriend/cancel request)
      allow delete: if isFriendshipMember(resource.data);
    }

    // =============================================================================
    // NOTIFICATIONS COLLECTION
    // =============================================================================
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      // Note: Notifications use recipientId field (not userId)
      // For queries: request.auth.uid must match the recipientId filter
      // For document reads: resource.data.recipientId must match request.auth.uid
      allow read: if isAuthenticated() &&
                     resource.data.recipientId == request.auth.uid;

      // Only system (Cloud Functions) can create notifications
      // Users cannot create notifications directly
      allow create: if false;

      // Users can update their own notifications (only mark as read)
      // Security: Restricts updates to read/readAt fields only, preventing content modification
      allow update: if isAuthenticated() &&
                       resource.data.recipientId == request.auth.uid &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read', 'readAt']);

      // Users can delete their own notifications
      allow delete: if isAuthenticated() &&
                       resource.data.recipientId == request.auth.uid;
    }

    // =============================================================================
    // ALBUMS COLLECTION
    // =============================================================================
    match /albums/{albumId} {
      // Users can read their own albums OR friends can read each other's albums
      allow read: if isAuthenticated() &&
                     (resource.data.userId == request.auth.uid ||
                      areFriends(resource.data.userId));

      // Users can create albums for themselves
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['userId', 'name', 'photoIds', 'coverPhotoId', 'createdAt']);

      // Users can update their own albums (userId and createdAt are immutable)
      allow update: if isOwner(resource.data.userId) &&
        !request.resource.data.diff(resource.data).affectedKeys().hasAny(['userId', 'createdAt']);

      // Users can delete their own albums
      allow delete: if isOwner(resource.data.userId);
    }

    // =============================================================================
    // BLOCKS COLLECTION (user blocking)
    // =============================================================================
    // Document ID format: {blockerId}_{blockedId}
    // Helper function to check if user is part of a block by parsing document ID
    // This allows reading non-existent documents to check if a block exists
    function isBlockMemberById(blockId) {
      let parts = blockId.split('_');
      return isAuthenticated() &&
             parts.size() == 2 &&
             (parts[0] == request.auth.uid || parts[1] == request.auth.uid);
    }

    match /blocks/{blockId} {
      // Read: Users can read blocks where they are blocker or blocked
      // - Blocker needs to see who they've blocked (for Unblock option)
      // - Blocked user needs to filter content from people who blocked them
      // Two cases:
      // 1. Document exists: check resource.data fields
      // 2. Document doesn't exist: check ID to allow "does block exist?" queries
      allow read: if (isAuthenticated() &&
                      (resource.data.blockerId == request.auth.uid ||
                       resource.data.blockedId == request.auth.uid)) ||
                     isBlockMemberById(blockId);

      // Create: Users can create blocks where they are the blocker
      allow create: if isAuthenticated() &&
                       request.resource.data.blockerId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['blockerId', 'blockedId', 'createdAt']);

      // Delete: Users can delete (unblock) blocks where they are the blocker
      allow delete: if isAuthenticated() &&
                       resource.data.blockerId == request.auth.uid;

      // Update: Not allowed (blocks are created/deleted, not updated)
      allow update: if false;
    }

    // =============================================================================
    // REPORTS COLLECTION (user reports)
    // =============================================================================
    // Document ID format: {reporterId}_{reportedUserId}_{timestamp}
    match /reports/{reportId} {
      // Read: Only admins/Cloud Functions (users cannot read reports)
      allow read: if false;

      // Create: Users can create reports with themselves as reporter
      allow create: if isAuthenticated() &&
                       request.resource.data.reporterId == request.auth.uid &&
                       request.resource.data.keys().hasAll(['reporterId', 'reportedUserId', 'reason', 'createdAt']);

      // Update/Delete: Not allowed (reports are immutable once created)
      allow update, delete: if false;
    }

    // =============================================================================
    // DEFAULT DENY
    // =============================================================================
    // Deny access to all other collections by default
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
